<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ | JS_KringKoter</title><meta name="author" content="JS_KringKoter"><meta name="copyright" content="JS_KringKoter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、让自己习惯C++条款01：视c++为一个语言联邦如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：  C部分：区块，语句，预处理器，内置数据类型，数组，指针等。 Object-Oriented C++（面向对象）：类型，封装，继承，多态等。 Te">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="https://jskringkoter.github.io/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/index.html">
<meta property="og:site_name" content="JS_KringKoter">
<meta property="og:description" content="一、让自己习惯C++条款01：视c++为一个语言联邦如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：  C部分：区块，语句，预处理器，内置数据类型，数组，指针等。 Object-Oriented C++（面向对象）：类型，封装，继承，多态等。 Te">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true">
<meta property="article:published_time" content="2023-04-25T08:56:49.000Z">
<meta property="article:modified_time" content="2023-05-16T02:11:48.821Z">
<meta property="article:author" content="JS_KringKoter">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true"><link rel="shortcut icon" href="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true"><link rel="canonical" href="https://jskringkoter.github.io/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-16 10:11:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/style/modify.css"><link rel="stylesheet" href="/fonts/font.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 往事</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 追忆</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 自设</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="JS_KringKoter"><span class="site-name">JS_KringKoter</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 往事</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 追忆</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 自设</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-25T08:56:49.000Z" title="发表于 2023-04-25 16:56:49">2023-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T02:11:48.821Z" title="更新于 2023-05-16 10:11:48">2023-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/#post-comment"><span class="waline-comment-count" data-path="/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h2><h3 id="条款01：视c-为一个语言联邦"><a href="#条款01：视c-为一个语言联邦" class="headerlink" title="条款01：视c++为一个语言联邦"></a>条款01：视c++为一个语言联邦</h3><p>如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：</p>
<ul>
<li>C部分：区块，语句，预处理器，内置数据类型，数组，指针等。</li>
<li>Object-Oriented C++（面向对象）：类型，封装，继承，多态等。</li>
<li>Template C++：泛型编程部分，提供了模板元编程。</li>
<li>STL标准模板库：包含容器，迭代器，算法以及函数对象等</li>
</ul>
<p>C++并不是一个带有一组守则的一体语言，而是四个次语言组成的联邦。</p>
<h3 id="条款02：尽量以const，emum，inline替换-define"><a href="#条款02：尽量以const，emum，inline替换-define" class="headerlink" title="条款02：尽量以const，emum，inline替换 #define"></a>条款02：尽量以const，emum，inline替换 #define</h3><p>“宁可以编译器替换预处理器。“</p>
<p>将<code>#define NUMBER 1.63</code>替换为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double Number = 1.63;</span><br></pre></td></tr></tbody></table></figure>

<p>当使用const替换时，有两种特殊情况：</p>
<ul>
<li>定义常量指针时</li>
</ul>
<p>常量表达式通常放在头文件内方便不同源码包含，有必要将指针（而不是指针所指之物声明为const）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> authorName = <span class="string">"Js_KringKoter"</span>;</span><br><span class="line"><span class="comment">//或使用更为合宜的string对象：</span></span><br><span class="line"><span class="type">const</span> string autherName = <span class="string">"JS_KringKoter"</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>class专属常量时</li>
</ul>
<p>为了将常量的作用域限制于class内，且防止其多次复制，有必要将其限定为static：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NameLenth = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述语句为NameLenth的声明而非定义，如果需要取该常量的地址，则需要在实现文件中对其定义：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Name::NameLenth;</span><br></pre></td></tr></tbody></table></figure>

<p>亦可使用enum hack补偿做法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> { NameLenth = <span class="number">5</span> };</span><br><span class="line">    <span class="type">int</span> scores[NameLenth];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>enum hack的行为与define较为相似，如取一个enum的地址为非法。</p>
<h4 id="使用inline函数代替-define"><a href="#使用inline函数代替-define" class="headerlink" title="使用inline函数代替#define"></a>使用inline函数代替#define</h4><p>#define可能会导致问题，如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b)        <span class="comment">//a被累加两次</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用template inline来代替：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CallWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span>  <span class="comment">//由于不知道T是什么，采用传递引用方式</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>对于单纯常量，最好以const对象或enums替换#defines。</li>
<li>对于形似函数的宏，最好改用inline函数代替#defines。</li>
</ul>
<span id="more"></span>

<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>只要某值保持不变是一个事实，则应使用const，确保这条约束不被违反。可以通过const修饰指针和指针所指向的对象，使其不被修改：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* pn = number;               <span class="comment">//非const指针，非const变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pn = number;         <span class="comment">//非const指针，const变量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> pn = number;         <span class="comment">//const指针，非const变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pn = number;   <span class="comment">//const指针，const变量</span></span><br></pre></td></tr></tbody></table></figure>

<p>当const出现在*左边，则变量为const；出现在右边，则指针为const。另一种写法是：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * pn = number;        <span class="comment">//有时会遇到，需要注意</span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="const-interator和const-interator"><a href="#const-interator和const-interator" class="headerlink" title="const interator和const_interator"></a>const interator和const_interator</h4><p>声明一个const interator和一个T* const一样，保证指向数据的指针为const；而const_iterator保证数据为const。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator citer = vec.<span class="built_in">begin</span>();   <span class="comment">//相当于T* const</span></span><br><span class="line">citer++;                                           <span class="comment">//非法</span></span><br><span class="line">*citer = <span class="number">10</span>;                                       <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iterc = vec.<span class="built_in">begin</span>();   <span class="comment">//相当于const T*</span></span><br><span class="line">iterc++;                                           <span class="comment">//合法</span></span><br><span class="line">*iterc = <span class="number">10</span>;                                       <span class="comment">//非法</span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="令函数返回const"><a href="#令函数返回const" class="headerlink" title="令函数返回const"></a>令函数返回const</h4><p>令函数返回一个const，可以降低因客户错误而造成的意外的同时，不至于放弃安全和高效性。考虑有理数（详见条款24）的operator*声明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {...};</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">//客户有时会因粗心而这样做：</span></span><br><span class="line">Rational a, b, c;</span><br><span class="line">(a * b) = c;</span><br></pre></td></tr></tbody></table></figure>

<p>将返回值设置为const可避免客户如此操作。</p>
<h4 id="使用const成员函数"><a href="#使用const成员函数" class="headerlink" title="使用const成员函数"></a>使用const成员函数</h4><p>使用const成员函数有两个目的，一是指明了此class接口不会修改对象内容，二是使得函数可以操作const对象。一个事实是：两个成员函数只是常量性不同，可以被重载。也就是说，可以构造两个重载函数，一个用于操作const类型，一个操作non-const类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lenth[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//此函数中无法修改类的成员，无法对返回值赋值。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    { <span class="keyword">return</span> lenth[locate]; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此函数中可以修改成员，对返回值赋值会导致成员被修改。</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate)</span><br><span class="line">    { <span class="keyword">return</span> lenth[locate]; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存在这样的函数，但会导致通过返回值修改const对象</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    { <span class="keyword">return</span> lenth[locate]; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数前const限定了无法修改返回值，函数后const决定函数是对const还是non-const对象操作。对于const对象，我们并不希望其被修改，必须重载双const成员函数。</p>
<p>需要注意的是，一个non-const char operator[]返回一个char，诸如<code>name[] = 'x'</code>是不被允许的，即使允许，修改的也是一个副本，而原本的数据不会改变。</p>
<h4 id="bitwise-constness和logical-constness"><a href="#bitwise-constness和logical-constness" class="headerlink" title="bitwise constness和logical constness"></a>bitwise constness和logical constness</h4><p>对于const该如何限定，有如上两派观点。BC派认为只有在不更改任何成员变量（static除外）时才能是const。这种观点可以很有效侦测违反点，但当出现指针指向了一个不属于类型的变量，如char* 字符串，const将失效：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> name[locate];</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Name name;</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">'x'</span>;        <span class="comment">//这条语句将通过编译，而且能够运行，最后结果是const对象的值被改变。</span></span><br></pre></td></tr></tbody></table></figure>



<p>LC派认为const对象内可以包含不影响const性的非const对象，一个const成员函数可以修改它所处理的某些bits，但只有在客户端侦测不出时才能如此。使用mutable关键字修饰的变量可在const成员函数中修改。如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pText;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">size_t</span> textLength;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;       <span class="comment">//使用mutable关键字</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (lengthIsValid == <span class="literal">false</span>) {</span><br><span class="line">		textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">		lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> textLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="让non-const调用const成员函数来减少代码重复"><a href="#让non-const调用const成员函数来减少代码重复" class="headerlink" title="让non-const调用const成员函数来减少代码重复"></a>让non-const调用const成员函数来减少代码重复</h4><p>很多情况下const成员函数和non-const成员函数代码基本相同，调用const对象，转化为non-const对象可以减少代码重复。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    { <span class="keyword">return</span> name[locate]; }</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt; ( <span class="built_in">static_cast</span>&lt;<span class="type">const</span> Name&amp;&gt; (*<span class="keyword">this</span>)[locate] );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>将某些东西声明为const有助于编译器侦测出错误用法。</li>
<li>编辑器强制实施bitwise constness，但编写程序时应使用“概念上的常量性”。</li>
<li>当const和non-const成员函数有实质等价的实现时，令non-const版本调用const可避免代码重复。</li>
</ul>
<h2 id="二、构造，析构，赋值运算"><a href="#二、构造，析构，赋值运算" class="headerlink" title="二、构造，析构，赋值运算"></a>二、构造，析构，赋值运算</h2><h3 id="条款04：确定对象使用前已被初始化"><a href="#条款04：确定对象使用前已被初始化" class="headerlink" title="条款04：确定对象使用前已被初始化"></a>条款04：确定对象使用前已被初始化</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name::<span class="built_in">Name</span>(<span class="type">int</span> a, string b, list&lt;<span class="type">int</span>&gt; c)</span><br><span class="line">{</span><br><span class="line">    length = a;       <span class="comment">//是初始化</span></span><br><span class="line">    str = b;          <span class="comment">//不是初始化，而是赋值</span></span><br><span class="line">    listInt = b;      <span class="comment">//不是初始化，而是赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于类构造函数，应尽可能使用初始化列表。初始化列表和赋值操作结果相同，但效率更高，原因是在创建成员类的时候无需调用赋值构造函数。应将上述代码改为：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name::<span class="built_in">Name</span>(<span class="type">int</span> a, string b, list&lt;<span class="type">int</span>&gt; c)</span><br><span class="line">    :<span class="built_in">length</span>(a),</span><br><span class="line">     <span class="built_in">str</span>(b),</span><br><span class="line">     <span class="built_in">listInt</span>(c)</span><br><span class="line">{ }                 <span class="comment">//构造函数无需任何操作</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要一个无参的default构造函数，则仅需指定无物作为初始化列表即可。</p>
<h4 id="将简单初始化移向函数"><a href="#将简单初始化移向函数" class="headerlink" title="将简单初始化移向函数"></a>将简单初始化移向函数</h4><p>对于有多个构造函数的类型，如果一部分内置类型重复，可以考虑将其移到单独的函数中，可以使用赋值初始化（伪初始化）。但通过列表初始化更为可取。</p>
<h4 id="一致声明顺序和初始化顺序"><a href="#一致声明顺序和初始化顺序" class="headerlink" title="一致声明顺序和初始化顺序"></a>一致声明顺序和初始化顺序</h4><p>别问，问就是防止晦涩错误，比如A需要B的值，但B在A后初始化。</p>
<h4 id="不同编译单元内的non-local-static对象的初始化"><a href="#不同编译单元内的non-local-static对象的初始化" class="headerlink" title="不同编译单元内的non-local static对象的初始化"></a>不同编译单元内的non-local static对象的初始化</h4><p>non-local static对象：在本函数内的static对象被称作local static对象，而其他不是函数内的static对象称作non-local static对象。</p>
<p>编译单元：可以理解为不同的两个文件，如两个头文件，各包含了一个static对象，这两个static对象和两个文件之间就是non-local static关系。</p>
<p>由于non-local static对象的初始化顺序并没有一定的规定，所以当一个编译单元的元素需要一个non-local static对象时，有可能该对象还没有被编译。看以下实例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;           <span class="comment">//预留给客户的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户在别处使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; tfs;          <span class="comment">//此时tfs不一定完成了初始化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当使用tfs的时候该对象不一定完成了初始化。这将导致灾难。解决办法是写一个函数，在函数内构建一个local static对象替换non-local static对象，返回一个指向该对象的引用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> FileSystem tfs;</span><br><span class="line">    <span class="keyword">return</span> tfs;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; <span class="built_in">tfs</span>();        <span class="comment">//调用tfs()，获得一个指向non-local tfs的引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该函数简单的reference-returning使得它很适合成为inline函数。对于多线程编程，有可能带有不确定性，需要在单线程启动阶段手动调用所有reference-returning函数。</p>
<p>总结：</p>
<ul>
<li>对内置对象进行手工初始化，因为C++不保证初始化它们。</li>
<li>构造函数最好使用初始化列表，不要在构造函数本体中使用赋值操作。初始化列表的成员顺序需要与声明列表一致。</li>
<li>为了防止跨编译单元的初始化顺序问题，需要使用local static替换non-local static。</li>
</ul>
<h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>对于一个没有提供函数的类，编译器自动为其编写 构造函数，析构函数，复制构造函数以及operator=()运算符函数。如果用户创建了一个含参数的构造函数，编译器将不再自动编写default构造函数。</p>
<p>对于复制构造函数，c++将一一拷贝类型内每个bits来完成初始化（注意复制构造函数仅在创建类时调用，赋值操作使用=运算符），一般不会出现问题，而重载的=运算符在遇到引用和指针时会出现问题，此时编译器拒绝生成对应的operator=()运算符函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> nameLength;</span><br><span class="line">	std::string&amp; name;                       <span class="comment">//成员为引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> <span class="type">int</span>&amp; namel, string&amp; na) :</span><br><span class="line">		<span class="built_in">nameLength</span>(namel),</span><br><span class="line">		<span class="built_in">name</span>(na)</span><br><span class="line">	{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">na1</span><span class="params">(<span class="string">"kringkoter"</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">na2</span><span class="params">(<span class="string">"rainimator"</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name1</span><span class="params">(<span class="number">2</span>, na1)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name2</span><span class="params">(<span class="number">3</span>, na2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    name1 = name2;             <span class="comment">//不被允许，c++拒绝生成operator=()函数。</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//错误信息：无法引用 函数 "Name::operator=(const Name &amp;)" (已隐式声明) -- 它是已删除的函数</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果需要使用一个内含引用或者const对象的类型，必须自己编写operator=函数，编译器不会做这件事。</p>
<p>总结：</p>
<ul>
<li>编译器可以暗自为class创建default构造函数，copy构造函数，copy assignment操作符函数，以及析构函数。</li>
</ul>
<h3 id="条款06：如果不想使用编译器提供的函数，就应当明确拒绝。"><a href="#条款06：如果不想使用编译器提供的函数，就应当明确拒绝。" class="headerlink" title="条款06：如果不想使用编译器提供的函数，就应当明确拒绝。"></a>条款06：如果不想使用编译器提供的函数，就应当明确拒绝。</h3><p>编译器可以自动创建复制和=运算符函数，有时并不希望使用这两个函数，但编译器会自动提供，此时需要明确拒绝。</p>
<h4 id="将函数原型置于private"><a href="#将函数原型置于private" class="headerlink" title="将函数原型置于private"></a>将函数原型置于private</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">Name</span>(<span class="type">const</span> Name&amp;);</span><br><span class="line">    Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp;);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将函数原型置于private使得其无法被除成员函数访问，且编译器不再自动提供。</p>
<h4 id="继承Base类，将函数原型置于Base"><a href="#继承Base类，将函数原型置于Base" class="headerlink" title="继承Base类，将函数原型置于Base"></a>继承Base类，将函数原型置于Base</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;);</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Name <span class="title">name1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    name1 = name2;      <span class="comment">//非法，错误信息：</span></span><br><span class="line">                        <span class="comment">//无法引用 函数 "Name::operator=(const Name &amp;)" (已隐式声明) -- 它是已删除的函数</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并不予实现。也可以使用base class办法。</li>
</ul>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>如果基类析构函数不是virtual，在析构指向派生类对象的基类指针时，仅仅调用基类析构函数，导致派生类成员无法正确析构，可能会导致内存泄漏。</p>
<p>如果基类含有virtual函数，几乎确定应该有一个virtual析构函数。如果基类不含有virtual函数，表示它并不意图做一个base class，一般不用声明virtual析构函数。</p>
<p>当需要一个抽象基类而又没有适合的纯虚函数时，可以将析构函数声明为纯虚，同时也解决了析构函数为虚的问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>带有多态性质的base class应该声明一个virtual析构函数。如果class带有任何virtual函数，应当拥有一个virtual析构函数。</li>
<li>如果类型不是为了多态而设计，或者不是base class，就不该声明virtual析构函数。</li>
</ul>
<h3 id="条款08：-不要让异常逃离析构函数"><a href="#条款08：-不要让异常逃离析构函数" class="headerlink" title="条款08：*不要让异常逃离析构函数"></a>条款08：*不要让异常逃离析构函数</h3><h3 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h3><p>有下列程序段：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">con</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Name</span>()</span><br><span class="line">	{ <span class="built_in">con</span>(); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Len</span> : <span class="keyword">public</span> Name {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">con</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">Len</span>()</span><br><span class="line">	{}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在生成Len对象时，首先调用base class构造函数，此时调用的virtual还“不是”virtual函数，它并没有使用派生类中的实现。</p>
<p>由于无法在构造函数中使用virtual函数，可以改用向base class传递必要的构造参量来代替。</p>
<h3 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令operator=返回一个reference to *this</h3><p>基本类型可以使用诸如<code>x = y = z;</code>的连续赋值，自定义类型也最好如此。想要实现这一功能，需要返回一个指向左值的引用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于其他赋值运算符，如+=，-=，*=等，也同样适用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator= 中处理自我赋值"></a>条款11：在operator= 中处理自我赋值</h3><h4 id="证同测试法"><a href="#证同测试法" class="headerlink" title="证同测试法"></a>证同测试法</h4><p>在实现最前面加上证同测试是传统做法，它能够处理自我赋值，但无法处理异常安全性。同时增加的判断语句减慢了代码运行速度。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">//证同测试</span></span><br><span class="line">    <span class="keyword">delete</span>[] pd;</span><br><span class="line">    pd = <span class="keyword">new</span> <span class="built_in">char</span>(*rhs.pd);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="临时变量法"><a href="#临时变量法" class="headerlink" title="临时变量法"></a>临时变量法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Name&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span>* newChar = pd;         <span class="comment">//获得一个pd的临时变量</span></span><br><span class="line">    pd = <span class="keyword">new</span> <span class="built_in">char</span>(*rhs.pd);     <span class="comment">//将pd指向新的内存空间，且值等于rhs.pd </span></span><br><span class="line">    <span class="keyword">delete</span>[] newChar;           <span class="comment">//删除临时变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="swap-and-copy法"><a href="#swap-and-copy法" class="headerlink" title="swap and copy法"></a>swap and copy法</h4><p>使用一个swap函数交换*this和rhs的数据。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span>;</span><br><span class="line"><span class="function">Name&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Name <span class="title">newName</span><span class="params">(rhs)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(newName);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>确保当对象自我赋值时operator=有良好的行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序，copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><p>每一个类中都会有copying构造函数和operator=函数，如果不显式声明，编译器会提供默认的函数。如果选择使用自己的函数，当有对象没有复制时，编辑器不会发出警告。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> len1;</span><br><span class="line">	<span class="type">int</span> len2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">int</span> l1, <span class="type">int</span> l2) </span><br><span class="line">		: <span class="built_in">len1</span>(l1),</span><br><span class="line">		  <span class="built_in">len2</span>(l2)</span><br><span class="line">	{}</span><br><span class="line">	~<span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">		: <span class="built_in">len1</span>(rhs.len1),</span><br><span class="line">		  <span class="built_in">len2</span>(rhs.len2)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		len1 = rhs.len1;</span><br><span class="line">		len2 = rhs.len2;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意将每一个对象都包括在内。</p>
<p>在遇到继承时，要注意复制基类对象。由于继承类无法直接访问基类私有成员，需要调用基类复制构造函数和operator=函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">N</span> : <span class="keyword">public</span> Name {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> len3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">N</span>(<span class="type">int</span> l1, <span class="type">int</span> l2, <span class="type">int</span> l3)</span><br><span class="line">		: <span class="built_in">Name</span>(l1, l2),</span><br><span class="line">		  <span class="built_in">len3</span>(l3)</span><br><span class="line">	{}</span><br><span class="line">	~<span class="built_in">N</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">N</span>(<span class="type">const</span> N&amp; rhs)</span><br><span class="line">		: <span class="built_in">Name</span>(rhs),            <span class="comment">//调用基类copying函数</span></span><br><span class="line">		  <span class="built_in">len3</span>(rhs.len3)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	N&amp; <span class="keyword">operator</span>=(<span class="type">const</span> N&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		Name::<span class="keyword">operator</span>=(rhs);   <span class="comment">//调用基类copy assignment函数</span></span><br><span class="line">		len3 = rhs.len3;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<p>总结</p>
<ul>
<li>copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应该将共同的代码放入一个init函数，并由两个copying函数共同调用。</li>
</ul>
<h2 id="三、资源管理"><a href="#三、资源管理" class="headerlink" title="三、资源管理"></a>三、资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>很多类拥有这样一个函数，它请求内存资源，返回一块内存空间，这样的函数成为factory函数（工厂函数）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoffeeBar* <span class="title">creatCOB</span><span class="params">()</span></span>;   <span class="comment">//返回指针，指向COB继承体系内的动态分配对象。</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于在函数内使用了new，使用者需要在使用函数后使用delete：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CoffeeBar* newCOB = <span class="built_in">creatCOB</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> CoffeeBar;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但在有的时候，delete有可能会被忽略，比如if，跳出了while，引发了异常等。这时内存得不到释放，即会发生内存泄漏。为确保资源归还给系统，可以把资源的控制权交给资源控制类来实现。可以使用unique_ptr和shared_ptr来管理内存。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    shared_ptr&lt;CoffeeBar&gt; newCOB = <span class="built_in">creatCOB</span>();</span><br><span class="line">    ...    </span><br><span class="line">}    <span class="comment">//在函数结束前，newCOB的析构函数将删除内存。</span></span><br></pre></td></tr></tbody></table></figure>

<p>对于资源管理，有以下两个注意点：</p>
<ul>
<li>获得资源后立刻将资源放入对象，使用资源管理对象来管理资源通常要比手动更加安全。资源取得时机便是初始化时机。</li>
<li>管理对象运用析构函数确保资源被释放。</li>
</ul>
<blockquote>
<p>share_ptr和unique_ptr包含在memory头文件内。</p>
<p>share_ptr被称作引用计数型智慧指针（RCSP），它持续追踪有多少对象指向资源，并在没有指向时删除它。</p>
</blockquote>
<h3 id="条款14：-在资源管理中小心copying行为"><a href="#条款14：-在资源管理中小心copying行为" class="headerlink" title="条款14：*在资源管理中小心copying行为"></a>条款14：*在资源管理中小心copying行为</h3><h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>由于不是所有API都需要资源管理对象，直接访问原始资源显得很重要。比如下面的例子，它需要一个原始指针，但传递了一个智能指针，这是不被允许的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">function</span>(pi);                   <span class="comment">//错误！</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要将智能指针显示转换为普通指针对象，才能通过编译。智能指针对象提供一个get()成员函数，返回一个普通指针指向管理的内存。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">function</span>(pi.<span class="built_in">get</span>());</span><br></pre></td></tr></tbody></table></figure>

<p>有时需要在自己的资源管理类中提供显式和隐式转换函数，用来适配原始资源的API：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ptr</span> {                                         <span class="comment">//这个类处理的是Cob类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cob <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> cob; }                 <span class="comment">//显式转换函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ptr</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Cob</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> cob; }            <span class="comment">//隐式转换函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这两者都存在问题，前者使得每次转换都需要条用get()函数（其实也没有那么烦），而隐式转换容易出现意外转换的问题：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ptr <span class="title">newPtr1</span><span class="params">(<span class="keyword">new</span> Cob)</span></span>;</span><br><span class="line">Cob newPtr2 = newPtr1;          <span class="comment">//本意是创建一个ptr对象。</span></span><br><span class="line">                                <span class="comment">//如果不声明隐式转换函数，则不会通过编译，减少了错误可能性。</span></span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>API通常要求访问原始资源，每一个RAII class应该提供一个取得管理的原始资源的方法。</li>
<li>对原始资源的访问可能经由显式和隐式转换，一般而言显示转换更加安全，但隐式转换对于客户来说更加方便。</li>
</ul>
<h3 id="条款16：成对使用new和delete时要采用相同形式"><a href="#条款16：成对使用new和delete时要采用相同形式" class="headerlink" title="条款16：成对使用new和delete时要采用相同形式"></a>条款16：成对使用new和delete时要采用相同形式</h3><p>如果在new表达式中使用[]，必须在相应的delete表达式中也使用[]。尽量避免对数组使用typedef：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string AddressLines[<span class="number">4</span>];</span><br><span class="line">string* pal = <span class="keyword">new</span> AddressLines;        <span class="comment">//这是个4元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;</span><br><span class="line"><span class="keyword">delete</span>[] pal;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="条款17：以独立语句将new对象置入智能指针内"><a href="#条款17：以独立语句将new对象置入智能指针内" class="headerlink" title="条款17：以独立语句将new对象置入智能指针内"></a>条款17：以独立语句将new对象置入智能指针内</h3><p>假设有个函数需要传递一个shared_ptr，该函数原型和调用如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt;, <span class="type">int</span> fun)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>(std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="type">int</span>), <span class="built_in">fun</span>());                         <span class="comment">//fun是一个返回int的函数</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样的调用可能会产生资源泄漏问题。在调用这样的函数时，需要进行三部操作：1.调用new int，2.调用shared_ptr<int>构造函数，3.调用fun()函数。</int></p>
<p>c++并没有规定这三者的调用顺序（除了第一步肯定在第二步之前，但第一步和第三步的顺序未定），可能出现调用fun后才调用shared_ptr构造函数，如果在fun中抛出了异常，new int请求的资源就无法进入智能指针中，无法正确析构。</p>
<p>避免这样的情况只需要使用一条单独的语句构造智能指针对象：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">function</span>(pi, <span class="built_in">fun</span>());</span><br></pre></td></tr></tbody></table></figure>

<p>这样即使抛出异常，请求的资源也能正确回到系统中。</p>
<p>总结：</p>
<ul>
<li>以独立语句将newed对象储存于智能指针中，如果不这样做，一旦抛出异常，有可能导致资源泄漏。</li>
</ul>
<h2 id="四、设计与声明"><a href="#四、设计与声明" class="headerlink" title="四、设计与声明"></a>四、设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h3><p>对于一个记录日期的类，它需要三个参数：年，月，日。对于不同的地区，这三个量的排列顺序有可能不同。对于下面的类：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> valYear, <span class="type">int</span> valMonth, <span class="type">int</span> valDay)</span><br><span class="line">        : <span class="built_in">year</span>(valYear),</span><br><span class="line">          <span class="built_in">month</span>(valMonth),</span><br><span class="line">          <span class="built_in">day</span>(valDay)</span><br><span class="line">    {}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>构造函数的正确调用应该是：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">2004</span>, <span class="number">5</span>, <span class="number">28</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>但由于某种地区原因，有人可能会这样写：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">28</span>, <span class="number">5</span>, <span class="number">2004</span>)</span></span>;          <span class="comment">//错误调用</span></span><br></pre></td></tr></tbody></table></figure>

<p>避免这样的情况发生，可以指定每一个元素一个数据类型（比如一个结构），取消隐式类型转换，这样使得接口更加清晰明了：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> {</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> day)</span> </span></span><br><span class="line"><span class="function">        : val(day) </span></span><br><span class="line"><span class="function">    {</span>}</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> {</span><br><span class="line">    <span class="built_in">Month</span>(<span class="type">int</span> month) </span><br><span class="line">        : <span class="built_in">val</span>(month)</span><br><span class="line">    {}</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> {</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function">        : val(year)</span></span><br><span class="line"><span class="function">    {</span>}</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Month month;</span><br><span class="line">	Day day;</span><br><span class="line">	Year year;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">const</span> Year&amp; valYear, <span class="type">const</span> Month&amp; valMonth, cosnt Day&amp; valDay)</span><br><span class="line">        : <span class="built_in">year</span>(valYear),</span><br><span class="line">          <span class="built_in">month</span>(valMonth),</span><br><span class="line">          <span class="built_in">day</span>(valDay)</span><br><span class="line">    {}</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>但是仍然有问题存在，比如客户传递了错误的月份。可以使用枚举量来代表某个月份，但那样很容易使得枚举量被用作int。所以使用静态成员函数，构造12个月份函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); };</span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); };</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> month)</span> : val(month) {</span>}</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这样调用就会变成：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(Year(<span class="number">2004</span>), Month::Jan(), Day(<span class="number">28</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>好的接口很容易被正常使用，不容易被误用，应该在所有接口中努力达成这些性质</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
</ul>
<h3 id="条款19：-设计class犹如设计type"><a href="#条款19：-设计class犹如设计type" class="headerlink" title="条款19：*设计class犹如设计type"></a>条款19：*设计class犹如设计type</h3><p>-看书看书看书看书-</p>
<h3 id="条款20：宁以传递const引用替换传值"><a href="#条款20：宁以传递const引用替换传值" class="headerlink" title="条款20：宁以传递const引用替换传值"></a>条款20：宁以传递const引用替换传值</h3><p>pass-by-value很多时候是费事且消耗资源的，在传递用户自定类型时需要传递引用以提高速度：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(CoffeeBar cob)</span></span>;          <span class="comment">//传递用户自定义类型有时很消耗资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> CoffeeBar&amp; cob)</span></span>;   <span class="comment">//修改之后</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用const使得程序不会在运行中修改数据。</p>
<p>对于内置类型和STL迭代器来说，传递引用有时并不优于传值，对于上述两者考虑使用pass-by-value。</p>
<h4 id="使用pass-by-reference-to-const防止对象切割"><a href="#使用pass-by-reference-to-const防止对象切割" class="headerlink" title="使用pass-by-reference-to-const防止对象切割"></a>使用pass-by-reference-to-const防止对象切割</h4><blockquote>
<p>对象切割：在继承体系中，将子类按值转换为基类时，子类成员丢失，且不具备子类特性（如使用子类virtual函数）。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">COB</span> : <span class="keyword">public</span> CoffeeBar {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(CoffeeBar c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    c.<span class="built_in">name</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个pass-by-value函数调用中，c.name()将解析为CoffeeBar::name()，而不是COB::name()。原因是按值传递时，c被初始化为基类对象，发生了对象切割。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> CoffeeBar&amp; c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    c.<span class="built_in">name</span>();                       <span class="comment">//这样就不会了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>修改如上，现在它能够正确反映多态。c.name()将解析为COB::name()。</p>
<p>总结：</p>
<ul>
<li>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并且可避免对象切割问题。</li>
<li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。</li>
</ul>
<h3 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h3><p>考虑一个有理数类，其中有一个operator*函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num) : <span class="built_in">val</span>(num) {}</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Rational</span>(rhs.val * val);</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>其operator*函数返回一个对象（而非引用）。这样需要付出额外的构造及析构成本，如果返回reference，则不需付出代价，但是会出现其他很多问题。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">ra1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">ra2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">Rational ra3 = ra1 * ra2;   <span class="comment">//ra1和ra2返回的引用存在吗？</span></span><br></pre></td></tr></tbody></table></figure>

<p>ra1 * ra2的值为30，但有没有值为30的对象呢，又有没有指向这个对象的引用呢？很明显没有。如果operator*要返回一个reference指向此值，必须自己创建对象。</p>
<p>但自己创建对象需要额外的构造及析构成本，这是pass-by-reference的初衷，但这样写已经违反了初衷，还会引发新的问题：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(rhs.val * val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在函数运行结束后，result对象被析构，此引用指向了一个并不存在的对象，这将导致无定义行为。</p>
<p>如果我们将本在栈区的对象放在堆区呢？这样反而会导致更多问题：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(rhs.val * val);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>确实返回了一个可用的引用，但问题是，应该在何处delete请求的资源呢？将这个工作抛给客户是不合理的。</p>
<h3 id="条款22：将成员变量声明为private："><a href="#条款22：将成员变量声明为private：" class="headerlink" title="条款22：将成员变量声明为private："></a>条款22：将成员变量声明为private：</h3><p>如果将成员变量声明为public或protected，意味着当某个变量发生改变（改名，或者是删除）时，客户码将会大幅度变化。另外，需要考虑封装性，当某个方法的实现改变时，客户不应当知道，也不应当需要修改客户码。</p>
<p>某物的封装性和“当改变其内容时造成的代码破坏量”成反比。protected和public一样，没有封装性。</p>
<p>记住：</p>
<ul>
<li>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束调节获得保证，并提供class作者充分的弹性。</li>
<li>protected并不比public更具封装性。</li>
</ul>
<h3 id="条款23：宁以non-member-non-friend函数代替member函数"><a href="#条款23：宁以non-member-non-friend函数代替member函数" class="headerlink" title="条款23：宁以non-member, non-friend函数代替member函数"></a>条款23：宁以non-member, non-friend函数代替member函数</h3><p>对于一个CoffeeBar类，其拥有三个成员变量，三个重置成员变量的函数。此时需要一个重置所有变量的函数，该函数有成员函数版本和非成员函数版本。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val1, val2, val3;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> v3)</span><br><span class="line">		: <span class="built_in">val1</span>(v1),</span><br><span class="line">		  <span class="built_in">val2</span>(v2),</span><br><span class="line">		  <span class="built_in">val3</span>(v3)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV1</span><span class="params">()</span> </span>{ val1 = <span class="number">0</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV2</span><span class="params">()</span> </span>{ val2 = <span class="number">0</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV3</span><span class="params">()</span> </span>{ val3 = <span class="number">0</span>; }</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetAll</span><span class="params">()</span>                      <span class="comment">//成员函数版本</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">resetV1</span>();</span><br><span class="line">		<span class="built_in">resetV2</span>();</span><br><span class="line">		<span class="built_in">resetV3</span>();</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetCob</span><span class="params">(CoffeeBar&amp; cob)</span>            <span class="comment">//非成员函数版本</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cob.<span class="built_in">resetV1</span>();</span><br><span class="line">	cob.<span class="built_in">resetV2</span>();</span><br><span class="line">	cob.<span class="built_in">resetV3</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面向对象守则要求，数据尽可能被封装。而封装性的判断标准从简单来说是：越多函数（member函数和friend函数）可以访问成员变量，封装性越差。</p>
<p>c++倾向于使用非成员函数，且非成员函数可以放在一个ntility工具类中，成为一个static函数。只要它不是CoffeeBar的一部分，他就不会影响封装性。比较自然的做法是让resetAll成为一个non-member函数并位于和Coffeebar相同的namespace内。</p>
<p>namespace可以跨越文件，而class不能。namespace内的对象可以不放在同一个文件中，只需要指名它属于同一个namesapce就可以了。</p>
<p>c++STL就是如此组织的，比如string，vector类，只需要包含特定的头文件，但它们都在namespaec std中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cob {</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val1, val2, val3;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> v3)</span><br><span class="line">		: <span class="built_in">val1</span>(v1),</span><br><span class="line">		  <span class="built_in">val2</span>(v2),</span><br><span class="line">		  <span class="built_in">val3</span>(v3)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV1</span><span class="params">()</span> </span>{ val1 = <span class="number">0</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV2</span><span class="params">()</span> </span>{ val2 = <span class="number">0</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV3</span><span class="params">()</span> </span>{ val3 = <span class="number">0</span>; }</span><br><span class="line">};</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cob {</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetCob</span><span class="params">(CoffeeBar&amp; cob)</span>            <span class="comment">//非成员函数版本</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cob.<span class="built_in">resetV1</span>();</span><br><span class="line">		cob.<span class="built_in">resetV2</span>();</span><br><span class="line">		cob.<span class="built_in">resetV3</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性，包裹弹性和机能扩充性。</li>
</ul>
<h3 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>对于一个有理数类型：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">val</span>(num)</span><br><span class="line">	{}</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>由于它是有理数类型，我们希望它能够和基本类型进行更加“明显的”乘法运算，比如ran * 4，首先4通过隐式类型转换，自动调用了构造函数转换为了Rational对象，再通过一个operator*函数返回一个Rational对象。如果乘法运算符函数是个成员函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(val, rhs.val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">ran</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; ran * <span class="number">4</span>;       <span class="comment">//正确</span></span><br><span class="line">cout &lt;&lt; <span class="number">4</span> * ran        <span class="comment">//错误！</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二条语句不能通过编译，原因如同下面的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ran.<span class="keyword">operator</span>*(<span class="number">4</span>);      <span class="comment">//正确</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">operator</span>*(ran);      <span class="comment">//错误！</span></span><br></pre></td></tr></tbody></table></figure>

<p>4没有对应的class，所以编译器试图寻找成员函数operator*失败，于是它在global寻找非成员函数版的operator函数，但没有找到。</p>
<p>4不在operator*()的参数列中（即函数调用不是operator(4）），无法进行隐式类型转换。此时需要一个非成员函数版本的运算符函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">val</span>(num)</span><br><span class="line">	{}</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span>          <span class="comment">//由于运算符函数传递const参数，后面的const是必须的</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">getVal</span>() * rhs.<span class="built_in">getVal</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果自定义的类型不必将所有类型转换为自定义类型，诸如此类的函数可以是member函数。</p>
<p>总结：</p>
<ul>
<li>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member。</li>
</ul>
<h3 id="条款25：-考虑写出一个不抛出异常的swap函数"><a href="#条款25：-考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：*考虑写出一个不抛出异常的swap函数"></a>条款25：*考虑写出一个不抛出异常的swap函数</h3><h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><h3 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h3><p>当定义了一个带有构造函数和析构函数的对象时，如果这个对象实际并未使用，仍需承受构造和析构成本。第二是当出现异常时，未使用的资源可能会浪费。</p>
<p>处理方法则是，只有当下一步就要用到这个对象，且可以对其进行初始化时，才能创建该对象。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">"KringKoter"</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> lenth = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>对于循环来说，在循环外声明的变量可以延续至循环后，且不必重复构造；但其可能重复调用复制函数。用哪个方法视具体情况而定。</p>
<p>总结：</p>
<ul>
<li>尽可能延后变量定义式的出现。这样做可以增加程序的清晰度并改善程序效率。</li>
</ul>
<h3 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h3><p>c++提供了四种“新式转型”，应在程序中代替旧式转型以增强程序可读性：</p>
<ul>
<li>const_cast&lt;&gt;通常用来将对象的常量性移除，它是唯一有此权力的c++ style转型操作符。</li>
<li>dynamic_cast&lt;&gt;用来执行“安全向下转型，它的运行成本耗费重大。</li>
<li>reinterpret_cast&lt;&gt;执行低级转型，如将一个int指针转化为int。</li>
<li>static_cast&lt;&gt;执行强制类型转换，可以将non-const对象转化为const，但无法反向将const转化为non-const。</li>
</ul>
<h4 id="转型获得的是副本"><a href="#转型获得的是副本" class="headerlink" title="转型获得的是副本"></a>转型获得的是副本</h4><p>就static_cast而言，其转换操作只是获得了其一个副本，其本身数据并没有改变。在继承体系中，尝试调用基类方法不能这样写：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;base&gt;(*<span class="keyword">this</span>).<span class="built_in">function</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>它其实调用了一个base副本的函数，并没有修改原始对象。应该这样写：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base::<span class="built_in">function</span>();</span><br></pre></td></tr></tbody></table></figure>



<h4 id="少用dynamic-cast，而改为直接使用派生类指针。"><a href="#少用dynamic-cast，而改为直接使用派生类指针。" class="headerlink" title="少用dynamic_cast，而改为直接使用派生类指针。"></a>少用dynamic_cast，而改为直接使用派生类指针。</h4><p>dynamic_cast转型需要耗费大量资源和时间，尝试替换下列代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Base&gt; newDerive;</span><br><span class="line"><span class="function"><span class="keyword">dynamic_cast</span>&lt;Derived*&gt; <span class="title">derive</span><span class="params">(newDerive-&gt;get())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line">shared_ptr&lt;Derived&gt; newDerive;</span><br><span class="line"><span class="function">Derived* <span class="title">derive</span><span class="params">(newDerive-&gt;get())</span></span>;</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>如果可以，尽量避免转型，特别是注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，设计无需转型的代替设计。</li>
<li>如果转型是必要的，将其放入函数。客户可以调用该函数。</li>
<li>宁可使用c++ style转型，不要使用旧式转型。前者很容易辨识。</li>
</ul>
<h3 id="条款28：避免返回handles指向对象的内部成分"><a href="#条款28：避免返回handles指向对象的内部成分" class="headerlink" title="条款28：避免返回handles指向对象的内部成分"></a>条款28：避免返回handles指向对象的内部成分</h3><p>考虑下面的对象，其使用一个结构来保存val，并在对象内使用指针指向结构来节省内存。考虑其成员函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v</span>{</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;v&gt; pv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> pv-&gt;val; }</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="function">Name <span class="title">name</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="type">int</span>&amp; n = name.<span class="built_in">getVal</span>();</span><br><span class="line">n = <span class="number">100</span>;                  <span class="comment">//修改了成员数据</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于返回了一个引用（套指针，如果此例没使用指针的话会编译出错，此条例有限制条件），在外部可以修改内部数据。而且当对象析构时，内部对象不复存在，而外部引用仍然指向内部对象，这会导致引用或指针挂起。</p>
<p>总结：</p>
<ul>
<li>避免返回引用，指针，迭代器指向对象内部。这样可以增加封装性，帮助const对象的行为像个const，并减少发生虚吊引用或指针的情况。</li>
</ul>
<h3 id="条款29：-“为异常安全”而努力是值得的"><a href="#条款29：-“为异常安全”而努力是值得的" class="headerlink" title="条款29：*“为异常安全”而努力是值得的"></a>条款29：*“为异常安全”而努力是值得的</h3><h3 id="条款30：透彻了解inline的里里外外"><a href="#条款30：透彻了解inline的里里外外" class="headerlink" title="条款30：透彻了解inline的里里外外"></a>条款30：透彻了解inline的里里外外</h3><h4 id="inline的组织方式"><a href="#inline的组织方式" class="headerlink" title="inline的组织方式"></a>inline的组织方式</h4><p>编译器处理inline函数的方式是，对于inline函数的每个调用，都使用相应的代码来代替它。当函数inline的代码很少时，编译器产出的代码可能比直接调用函数更少。如果如此，将增加程序的处理速度。但是，使用代码来替换调用使得inline函数没有地址，对其的函数指针将创建一个outline函数对象。</p>
<h4 id="请求inline函数"><a href="#请求inline函数" class="headerlink" title="请求inline函数"></a>请求inline函数</h4><p>inline关键字只是一个对编译器的申请，编译器有权利不理会。有时候inline函数并不需要明确指出，只需将函数定义于class内。这样的函数通常是成员函数，定义于class内的friend函数也是inline：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> </span>{ <span class="keyword">return</span> val; }       <span class="comment">//隐式的inline函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>明确声明为inline需要使用inline关键字，inline函数通常声明于头文件之内，因为编译器需要知道其如何实现。function template通常也声明于头文件内，很多程序员认为template函数一定要声明为inline。但这是个错误的想法，只有当确定其所有版本的函数都需要inline，才能将其声明为inline。</p>
<h4 id="编译器可能拒绝inline"><a href="#编译器可能拒绝inline" class="headerlink" title="编译器可能拒绝inline"></a>编译器可能拒绝inline</h4><p>有的时候编译器确实有意向生成一个inline，但还是为其提供一个outline函数对象。编译器通常不对virtual函数实行inline，因为需要等待运行期才能知道调用哪个函数。</p>
<p>空的构造函数看上去很适合成为inline函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> : <span class="keyword">public</span> Coffeebar{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但空的构造函数实际上并不是空的。编译器在其中添加了Base class的构造函数，初始化str和其他变量的方法，异常处理……如果上述函数也是inline，构造函数的代码量将极其庞大。</p>
<p>同时，将函数声明为inling会使得程序的更新变得复杂。在改变inline函数后，客户端需要重新编译。</p>
<p>掌握一个合乎逻辑的规则：一开始先不声明任何函数为inline，在合理的情况下声明为inline，并竭力减少其代码量。</p>
<h3 id="条款31：将文件之间的编译关系降到最低"><a href="#条款31：将文件之间的编译关系降到最低" class="headerlink" title="条款31：将文件之间的编译关系降到最低"></a>条款31：将文件之间的编译关系降到最低</h3><p>一个类的定义式不止详细叙述了其接口，还包括了十足的实现细目。当我们改变实现（甚至仅仅是一个变量的名字）时，所有有关文件都需要重新编译连接。但如果提供声明式，客户看到的只是接口，而无关实现。当实现改变时，和接口没有关系，客户便无需修改。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义式，包含了所有实现细目。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cob.h"</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() {...}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式，仅包含接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cob</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当一个类型的实现十分庞大时，当其实现代码改变时，我们需要重新编译连接。我们并不希望这样的情况发生。</p>
<h4 id="handle-class法"><a href="#handle-class法" class="headerlink" title="handle class法"></a>handle class法</h4><p>handle class将类型拆分为二，一个仅包含接口，通过一个指针指向另一个；另一个包含完整实现。这样，当实现改变时，客户无需重新编译连接，因为接口没有发生改变。</p>
<p>Implementation.h</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBarImpl</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CoffeeBarImpl</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">name</span>(name_), <span class="built_in">age</span>(age_)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CoffeeBarImpl</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> age; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span> </span>{ age = val; }</span><br><span class="line">	<span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> name; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> </span>{ name = val; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>CoffeeBar.h</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"implementation.h"</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;CoffeeBarImpl&gt; pImpl;       <span class="comment">//指向imlp的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">CoffeeBarImpl</span>(name_, age_))</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Coffeebar.cpp</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Coffeebar.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"implementation.h"</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CoffeeBar::getAge</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> pImpl-&gt;<span class="built_in">getAge</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CoffeeBar::setAge</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pImpl-&gt;<span class="built_in">setAge</span>(val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">CoffeeBar::getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> pImpl-&gt;<span class="built_in">getName</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CoffeeBar::setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pImpl-&gt;<span class="built_in">setName</span>(val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Implementation提供了实现细目，而Coffeebar只是调用其中的方法。将定义式和声明式置于两个不同的头文件中，客户在使用时只需要包含声明式头文件即可。</p>
<h4 id="Interface-class法"><a href="#Interface-class法" class="headerlink" title="Interface class法"></a>Interface class法</h4><p>interface class法声明一个抽象基类，使用该抽象基类派生一个类。基类和派生类拥有一样的接口，但具体实现在派生类中。基类中包含一个factory函数，生产一个指向派生类的基类指针供使用。在使用时，调用factory函数获得一个指向派生类的基类指针，使用基类virtual接口，调用实际是派生类方法。</p>
<p>Base.h</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">COBBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;COBBase&gt; <span class="title">creatCOB</span><span class="params">(<span class="type">const</span> std::string name_, <span class="type">int</span> age_)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">	    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;COBBase&gt;(<span class="keyword">new</span> <span class="built_in">Coffeebar</span>(name_, age_));</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">//返回基类指针，指向派生类对象，可使用派生类virtual函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">COBBase</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Coffeebar.h</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coffeebar</span> : <span class="keyword">public</span> COBBase {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Coffeebar</span>(<span class="type">const</span> std::string name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">name</span>(name_),</span><br><span class="line">		  <span class="built_in">age</span>(age_)</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Coffeebar</span>()</span><br><span class="line">	{}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>成员函数实现文件和上一个方法基本一致。</p>
<p>总结：</p>
<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle class和interface class（将接口和实现分离）。</li>
</ul>
<h2 id="六、继承与面向对象"><a href="#六、继承与面向对象" class="headerlink" title="六、继承与面向对象"></a>六、继承与面向对象</h2><h3 id="条款32：确定在你的public继承塑膜出is-a关系"><a href="#条款32：确定在你的public继承塑膜出is-a关系" class="headerlink" title="条款32：确定在你的public继承塑膜出is-a关系"></a>条款32：确定在你的public继承塑膜出is-a关系</h3><p>class之间的关系有三种：is-a，has-a，is-implemented-in-terms-of（根据某物实现出）。public继承要求严格is-a关系，也就是适用于base的每一件事情都适用于derived class。每一个derived class对象都是一个base class对象。</p>
<h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p>在继承体系中，如果派生类尝试重载基类接口，基类接口将直接被掩盖，而并非被重载。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">()</span> </span>{ val = <span class="number">5</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">()</span> </span>{ val = <span class="number">2</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//即使接口只改变了参数列表，仍然不是重载，而是覆盖</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">(<span class="type">int</span> s)</span> </span>{ <span class="built_in">getVal</span>() = <span class="number">1</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">(<span class="type">int</span> n)</span> </span>{ <span class="built_in">getVal</span>() = <span class="number">4</span>; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>解决方法：使用using指令，使得基类函数作用域扩大：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用using</span></span><br><span class="line">    <span class="comment">//现在set1有两个重载版本：set1(), set1(int)</span></span><br><span class="line">	<span class="keyword">using</span> Base::set1;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">(<span class="type">int</span> s)</span> </span>{ <span class="built_in">getVal</span>() = <span class="number">1</span>; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">(<span class="type">int</span> n)</span> </span>{ <span class="built_in">getVal</span>() = <span class="number">4</span>; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h4 id="补充：函数与作用域"><a href="#补充：函数与作用域" class="headerlink" title="补充：函数与作用域"></a>补充：函数与作用域</h4><p>假设一个derived class的方法像这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFun</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当编译器看到这里的fun时，它会现在local作用域（也就是baseFun中查找），但一无所获。之后它将查找其外围作用域，即Dervied class中，仍然一无所获。在之后它查找Derived class外，也就是Base class中，如果找到，则停止查找。如果再没有找到，它将检索#include的头文件中是否存在。如果还是没有，则发生编译时错误。</p>
<p>总结：</p>
<ul>
<li>derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的函数重见天日，成为一个重载版本，可使用using声明式。</li>
</ul>
<h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p>在对基类方法的继承中，我们可能需要</p>
<ul>
<li>仅继承接口，并要求派生类提供实现</li>
<li>继承接口和实现，但希望派生类覆写实现</li>
<li>继承接口和实现，且不允许覆写实现</li>
</ul>
<p>对应的方法类型为pure virtual函数，simple pure virtual函数和non virtual函数。</p>
<h4 id="仅继承接口，要求派生类提供实现"><a href="#仅继承接口，要求派生类提供实现" class="headerlink" title="仅继承接口，要求派生类提供实现"></a>仅继承接口，要求派生类提供实现</h4><p>一个抽象基类：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的派生类只继承了它的接口，即函数定义，但没有实现。派生类需要自己提供实现。</p>
<ul>
<li>声明一个pure virtual函数的目的是让derived class只继承接口。</li>
</ul>
<p>然而，可以给纯虚函数提供一份实现代码，由于抽象类无法创建具体对象，只有通过VirtualBase::draw()来访问：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Virtual::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VirtualBase::<span class="built_in">draw</span>(<span class="number">8</span>);</span><br></pre></td></tr></tbody></table></figure>



<h4 id="继承接口和实现，但希望派生类覆写实现"><a href="#继承接口和实现，但希望派生类覆写实现" class="headerlink" title="继承接口和实现，但希望派生类覆写实现"></a>继承接口和实现，但希望派生类覆写实现</h4><p>simple virtual函数通常会提供一份实现代码，在派生类缺省时调用。虽然派生类可以对其覆写，但仍然可以使用其缺省版本。它告诉客户：你必须支持一个virtual函数，但如果你不想自己写， 你可以使用基类的缺省版本。</p>
<ul>
<li>simple virtual函数是让derived继承该函数的接口和缺省实现。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//缺省代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Virtual::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样存在问题：如果客户新建类型继承自此基类，但忘记了覆写代码，其将自动调用缺省实现，且不会发生编译器错误（错误在编译器出现要好于在运行期出现）。</p>
<p>解决方法是：除非用户提出使用缺省实现，否则不提供。</p>
<ul>
<li>提供一份缺省代码，置于protected中：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doDraw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">paint</span>(locate);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用缺省实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span> : <span class="keyword">public</span> VirtualBase {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">doDraw</span>(paint);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用覆写实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span> : <span class="keyword">public</span> VirtualBase {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">doOther</span>(locate);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>将原simple virtual函数改为pure virtual函数，提供一份该函数的实现。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VirtualBase::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用缺省实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span> : <span class="keyword">public</span> VirtualBase {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        VirtualBase::<span class="built_in">draw</span>(locate);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用覆写实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span> : <span class="keyword">public</span> VirtualBase {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">doOther</span>(locate);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="继承接口和实现，且不允许覆写实现"><a href="#继承接口和实现，且不允许覆写实现" class="headerlink" title="继承接口和实现，且不允许覆写实现"></a>继承接口和实现，且不允许覆写实现</h4><ul>
<li>声明non-virtual函数的目的是为了零derived class继承函数的接口及一份强制性实现。</li>
</ul>
<p>总结：</p>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>pure virtual函数只指定接口继承。</li>
<li>simple virtual函数具体指定接口继承且提供缺省实现。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p>当继承的函数是virtual或pure virtual，且提供了一份缺省参数时，重新定义缺省参数值将引发错误：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> val = <span class="number">0</span>)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(string val = <span class="string">"NONE"</span>)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">A* pb = <span class="keyword">new</span> B;     <span class="comment">//创建一个A指向B的指针</span></span><br><span class="line">B-&gt;<span class="built_in">draw</span>();         <span class="comment">//调用B的draw函数，没有提供参数。</span></span><br></pre></td></tr></tbody></table></figure>

<p>在没有提供参数的情况下，B的draw函数提供了来自A的默认参数，即B-&gt;draw(int val = 0)。</p>
<p>解决办法：将virtual函数置于private，并提供一个non-virtual函数提供缺省参数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://JSKringKoter.github.io">JS_KringKoter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jskringkoter.github.io/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/">https://jskringkoter.github.io/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JSKringKoter.github.io" target="_blank">JS_KringKoter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/08/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="C++并发编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++并发编程</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/23/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8%E7%9A%84python/" title="从入门到入门的python"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从入门到入门的python</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/16/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="C++数据结构与算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">C++数据结构与算法</div></div></a></div><div><a href="/2023/05/08/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="C++并发编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="title">C++并发编程</div></div></a></div><div><a href="/2023/04/04/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/vector%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="vector模板库和迭代器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">vector模板库和迭代器</div></div></a></div><div><a href="/2023/04/04/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB/" title="智能指针模板类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">智能指针模板类</div></div></a></div><div><a href="/2023/04/06/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/" title="顺序容器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-06</div><div class="title">顺序容器</div></div></a></div><div><a href="/2023/04/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%94%B9%E8%BF%9B%E5%92%8C%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="概念，改进和模型，深入探讨迭代器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-05</div><div class="title">概念，改进和模型，深入探讨迭代器</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/avatar.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">JS_KringKoter</div><div class="author-info__description">山 海 行 人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JSKringKoter"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JSKringKoter" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2265757077@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><span style="color:rgb(147, 80, 255); font-weight:700; align:center">这是JS_KringKoter的博客</span><br> <span style="color:rgb(147, 80, 255)">你也可以叫ta克林沃特</span><br> <span style="color:rgb(147, 80, 255)">ta是个程序员，但时常喜欢写文章</span><br> <span style="color:rgb(147, 80, 255)">标头的那几句话，尝试在这的故事里找到吧</span><br> <span style="color:rgb(147, 80, 255)">在页面的右上方有一篇ta的自设</span><br> <span style="color:rgb(147, 80, 255)">你也可以在追忆中找到ta笔下的角色</span><br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-number">1.</span> <span class="toc-text">一、让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86c-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-number">1.1.</span> <span class="toc-text">条款01：视c++为一个语言联邦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cemum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.2.</span> <span class="toc-text">条款02：尽量以const，emum，inline替换 #define</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8inline%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF-define"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用inline函数代替#define</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.3.</span> <span class="toc-text">条款03：尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-interator%E5%92%8Cconst-interator"><span class="toc-number">1.3.1.</span> <span class="toc-text">const interator和const_interator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9Econst"><span class="toc-number">1.3.2.</span> <span class="toc-text">令函数返回const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitwise-constness%E5%92%8Clogical-constness"><span class="toc-number">1.3.4.</span> <span class="toc-text">bitwise constness和logical constness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9non-const%E8%B0%83%E7%94%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9D%A5%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">让non-const调用const成员函数来减少代码重复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%EF%BC%8C%E6%9E%90%E6%9E%84%EF%BC%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">二、构造，析构，赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">条款04：确定对象使用前已被初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%AE%80%E5%8D%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A7%BB%E5%90%91%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">将简单初始化移向函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">一致声明顺序和初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E5%86%85%E7%9A%84non-local-static%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.3.</span> <span class="toc-text">不同编译单元内的non-local static对象的初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">条款05：了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E5%BD%93%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">条款06：如果不想使用编译器提供的函数，就应当明确拒绝。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E7%BD%AE%E4%BA%8Eprivate"><span class="toc-number">2.3.1.</span> <span class="toc-text">将函数原型置于private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFBase%E7%B1%BB%EF%BC%8C%E5%B0%86%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E7%BD%AE%E4%BA%8EBase"><span class="toc-number">2.3.2.</span> <span class="toc-text">继承Base类，将函数原型置于Base</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A-%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">条款08：*不要让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">条款09：绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-number">2.7.</span> <span class="toc-text">条款10：令operator=返回一个reference to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC"><span class="toc-number">2.8.</span> <span class="toc-text">条款11：在operator= 中处理自我赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E5%90%8C%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">2.8.1.</span> <span class="toc-text">证同测试法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E6%B3%95"><span class="toc-number">2.8.2.</span> <span class="toc-text">临时变量法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swap-and-copy%E6%B3%95"><span class="toc-number">2.8.3.</span> <span class="toc-text">swap and copy法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">2.9.</span> <span class="toc-text">条款12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">三、资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">3.1.</span> <span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.</span> <span class="toc-text">条款14：*在资源管理中小心copying行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">3.3.</span> <span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E7%94%A8%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">条款16：成对使用new和delete时要采用相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%86%85"><span class="toc-number">3.5.</span> <span class="toc-text">条款17：以独立语句将new对象置入智能指针内</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">四、设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">条款18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-number">4.2.</span> <span class="toc-text">条款19：*设计class犹如设计type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5%E4%BC%A0%E9%80%92const%E5%BC%95%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BC%A0%E5%80%BC"><span class="toc-number">4.3.</span> <span class="toc-text">条款20：宁以传递const引用替换传值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8pass-by-reference-to-const%E9%98%B2%E6%AD%A2%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2"><span class="toc-number">4.3.1.</span> <span class="toc-text">使用pass-by-reference-to-const防止对象切割</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-number">4.4.</span> <span class="toc-text">条款21：必须返回对象时，别妄想返回其reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">条款22：将成员变量声明为private：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member-non-friend%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BFmember%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">条款23：宁以non-member, non-friend函数代替member函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">条款24：若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">条款25：*考虑写出一个不抛出异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">五、实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">5.1.</span> <span class="toc-text">条款26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%9E%8B%E8%8E%B7%E5%BE%97%E7%9A%84%E6%98%AF%E5%89%AF%E6%9C%AC"><span class="toc-number">5.2.1.</span> <span class="toc-text">转型获得的是副本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%91%E7%94%A8dynamic-cast%EF%BC%8C%E8%80%8C%E6%94%B9%E4%B8%BA%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%8C%87%E9%92%88%E3%80%82"><span class="toc-number">5.2.2.</span> <span class="toc-text">少用dynamic_cast，而改为直接使用派生类指针。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">5.3.</span> <span class="toc-text">条款28：避免返回handles指向对象的内部成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A-%E2%80%9C%E4%B8%BA%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">5.4.</span> <span class="toc-text">条款29：*“为异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inline%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">5.5.</span> <span class="toc-text">条款30：透彻了解inline的里里外外</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inline%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">5.5.1.</span> <span class="toc-text">inline的组织方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82inline%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text">请求inline函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E8%83%BD%E6%8B%92%E7%BB%9Dinline"><span class="toc-number">5.5.3.</span> <span class="toc-text">编译器可能拒绝inline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E5%85%B3%E7%B3%BB%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E"><span class="toc-number">5.6.</span> <span class="toc-text">条款31：将文件之间的编译关系降到最低</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handle-class%E6%B3%95"><span class="toc-number">5.6.1.</span> <span class="toc-text">handle class法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interface-class%E6%B3%95"><span class="toc-number">5.6.2.</span> <span class="toc-text">Interface class法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">六、继承与面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%9C%A8%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E8%86%9C%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">条款32：确定在你的public继承塑膜出is-a关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">6.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">补充：函数与作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%A6%81%E6%B1%82%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">仅继承接口，要求派生类提供实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BD%86%E5%B8%8C%E6%9C%9B%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%A6%86%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">继承接口和实现，但希望派生类覆写实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%94%E4%B8%8D%E5%85%81%E8%AE%B8%E8%A6%86%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.3.</span> <span class="toc-text">继承接口和实现，且不允许覆写实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">6.4.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/16/JavaWeb/Mybatis/" title="Mybatis"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/cover/mybatis.png?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis"></a><div class="content"><a class="title" href="/2023/10/16/JavaWeb/Mybatis/" title="Mybatis">Mybatis</a><time datetime="2023-10-16T06:36:48.000Z" title="发表于 2023-10-16 14:36:48">2023-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/JavaWeb/MySQL/" title="MySQL"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/cover/mysql.png?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"></a><div class="content"><a class="title" href="/2023/10/09/JavaWeb/MySQL/" title="MySQL">MySQL</a><time datetime="2023-10-09T06:18:21.000Z" title="发表于 2023-10-09 14:18:21">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/26/JavaWeb/SpringBoot/" title="SpringBoot开发"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/cover/springboot.png?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot开发"></a><div class="content"><a class="title" href="/2023/09/26/JavaWeb/SpringBoot/" title="SpringBoot开发">SpringBoot开发</a><time datetime="2023-09-26T05:17:25.000Z" title="发表于 2023-09-26 13:17:25">2023-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/26/JavaWeb/Maven%E9%A1%B9%E7%9B%AE/" title="Maven项目"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/cover/Maven.png?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven项目"></a><div class="content"><a class="title" href="/2023/09/26/JavaWeb/Maven%E9%A1%B9%E7%9B%AE/" title="Maven项目">Maven项目</a><time datetime="2023-09-26T00:52:17.000Z" title="发表于 2023-09-26 08:52:17">2023-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/21/JavaWeb/VueElement/" title="Vue·Element-UI"><img src="https://github.com/JSKringKoter/JSKringKoter.github.io/blob/main/img/cover/vue.png?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue·Element-UI"></a><div class="content"><a class="title" href="/2023/09/21/JavaWeb/VueElement/" title="Vue·Element-UI">Vue·Element-UI</a><time datetime="2023-09-21T08:25:29.000Z" title="发表于 2023-09-21 16:25:29">2023-09-21</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 By JS_KringKoter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人活着就是为了秋千·斯通古</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-72ls4qzcx-jskringkoters-projects.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div class="aplayer no-destroy" data-id="2858602463" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/kade6zqy4vcce9bvxoejbg5q8mq8w1qz.js" async="async"></script><script>(() => {
  const isChatBtn = false
  const isChatHideShow = false

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'KS89AGU22K',
    apiKey: 'c47018dfadcc34705da5a010f4e7988d',
    indexName: 'jskringkoterio',
    container: '#docsearch',
  }, null))


  const searchClickFn = () => {
    document.querySelector('#search-button > .search').addEventListener('click', () => {
      document.querySelector('.DocSearch-Button').click()
    })
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>