<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>Effective C++ | JS_KringKoter | Personal blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="一、让自己习惯C++条款01：视c++为一个语言联邦如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：  C部分：区块，语句，预处理器，内置数据类型，数组，指针等。 Object-Oriented C++（面向对象）：类型，封装，继承，多态等。 Te">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="https://jskringkoter.github.io/2023/04/25/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective%20C++/index.html">
<meta property="og:site_name" content="JS_KringKoter | Personal blog">
<meta property="og:description" content="一、让自己习惯C++条款01：视c++为一个语言联邦如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：  C部分：区块，语句，预处理器，内置数据类型，数组，指针等。 Object-Oriented C++（面向对象）：类型，封装，继承，多态等。 Te">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-25T08:56:49.000Z">
<meta property="article:modified_time" content="2023-05-16T02:11:48.821Z">
<meta property="article:author" content="JS_KringKoter">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="JS_KringKoter | Personal blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>JS_KringKoter | Personal blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Your Name </div>
      <div class="dot"></div>
      <div class="subtitle">This is the subtitle </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://store.steampowered.com" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Unreal-Engine/" rel="tag">Unreal Engine</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B0%8F%E8%AF%B4/" rel="tag">小说</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%95%A3%E6%96%87/" rel="tag">散文</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%97%A7%E4%BD%9C%E4%B8%BA%E6%96%B0/" rel="tag">旧作为新</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%9F%B3%E4%B9%90%F0%9F%8E%B6/" rel="tag">音乐🎶</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2023/09 ">
          九月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/07 ">
          七月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/05 ">
          五月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/04 ">
          四月 2023 
          <div class="archive-count">10 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/03 ">
          三月 2023 
          <div class="archive-count">7 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/2023/09/18/HTML/" title="HTML" >
            <div class="recent-link-text">
              HTML
            </div>
          </a>
        
          <a class="recent-link" href="/2023/09/13/%E6%96%87%E7%AB%A0/%E9%BB%84%E6%98%8F%E7%9A%84%E9%AD%94%E6%9C%AF%E5%B8%88/" title="黄昏的魔术师" >
            <div class="recent-link-text">
              黄昏的魔术师
            </div>
          </a>
        
          <a class="recent-link" href="/2023/08/31/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E6%A2%A6/" title="Galgame：《天空之梦·Dreamland Sky》" >
            <div class="recent-link-text">
              Galgame：《天空之梦·Dreamland Sky》
            </div>
          </a>
        
          <a class="recent-link" href="/2023/08/31/%E6%96%87%E7%AB%A0/%E7%A9%BA%E7%AE%B1/" title="空箱" >
            <div class="recent-link-text">
              空箱
            </div>
          </a>
        
          <a class="recent-link" href="/2023/07/23/%E6%96%87%E7%AB%A0/%E5%B1%B1%E6%B5%B7%E8%A1%8C%E4%BA%BA/" title="山海行人" >
            <div class="recent-link-text">
              山海行人
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-C++学习笔记/Effective C++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Effective C++
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-04-25T08:56:49.000Z" itemprop="datePublished">2023-04-25</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    未分类 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            26k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h2 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h2><h3 id="条款01：视c-为一个语言联邦"><a href="#条款01：视c-为一个语言联邦" class="headerlink" title="条款01：视c++为一个语言联邦"></a>条款01：视c++为一个语言联邦</h3><p>如今的c++是一种多重泛型编程语言，同时支持面向过程，面向对象，函数形式，泛型形式，元编程形式的语言。可以这样理解C++：C++是一个由相关语言组成的语言联邦而并非单一语言。c++的主要次语言有四种：</p>
<ul>
<li>C部分：区块，语句，预处理器，内置数据类型，数组，指针等。</li>
<li>Object-Oriented C++（面向对象）：类型，封装，继承，多态等。</li>
<li>Template C++：泛型编程部分，提供了模板元编程。</li>
<li>STL标准模板库：包含容器，迭代器，算法以及函数对象等</li>
</ul>
<p>C++并不是一个带有一组守则的一体语言，而是四个次语言组成的联邦。</p>
<h3 id="条款02：尽量以const，emum，inline替换-define"><a href="#条款02：尽量以const，emum，inline替换-define" class="headerlink" title="条款02：尽量以const，emum，inline替换 #define"></a>条款02：尽量以const，emum，inline替换 #define</h3><p>“宁可以编译器替换预处理器。“</p>
<p>将<code>#define NUMBER 1.63</code>替换为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double Number = 1.63;</span><br></pre></td></tr></table></figure>

<p>当使用const替换时，有两种特殊情况：</p>
<ul>
<li>定义常量指针时</li>
</ul>
<p>常量表达式通常放在头文件内方便不同源码包含，有必要将指针（而不是指针所指之物声明为const）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> authorName = <span class="string">&quot;Js_KringKoter&quot;</span>;</span><br><span class="line"><span class="comment">//或使用更为合宜的string对象：</span></span><br><span class="line"><span class="type">const</span> string autherName = <span class="string">&quot;JS_KringKoter&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>class专属常量时</li>
</ul>
<p>为了将常量的作用域限制于class内，且防止其多次复制，有必要将其限定为static：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NameLenth = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述语句为NameLenth的声明而非定义，如果需要取该常量的地址，则需要在实现文件中对其定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Name::NameLenth;</span><br></pre></td></tr></table></figure>

<p>亦可使用enum hack补偿做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NameLenth = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> scores[NameLenth];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enum hack的行为与define较为相似，如取一个enum的地址为非法。</p>
<h4 id="使用inline函数代替-define"><a href="#使用inline函数代替-define" class="headerlink" title="使用inline函数代替#define"></a>使用inline函数代替#define</h4><p>#define可能会导致问题，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b)        <span class="comment">//a被累加两次</span></span><br></pre></td></tr></table></figure>

<p>使用template inline来代替：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CallWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span>  <span class="comment">//由于不知道T是什么，采用传递引用方式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>对于单纯常量，最好以const对象或enums替换#defines。</li>
<li>对于形似函数的宏，最好改用inline函数代替#defines。</li>
</ul>
<span id="more"></span>

<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>只要某值保持不变是一个事实，则应使用const，确保这条约束不被违反。可以通过const修饰指针和指针所指向的对象，使其不被修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* pn = number;               <span class="comment">//非const指针，非const变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pn = number;         <span class="comment">//非const指针，const变量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> pn = number;         <span class="comment">//const指针，非const变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pn = number;   <span class="comment">//const指针，const变量</span></span><br></pre></td></tr></table></figure>

<p>当const出现在*左边，则变量为const；出现在右边，则指针为const。另一种写法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * pn = number;        <span class="comment">//有时会遇到，需要注意</span></span><br></pre></td></tr></table></figure>



<h4 id="const-interator和const-interator"><a href="#const-interator和const-interator" class="headerlink" title="const interator和const_interator"></a>const interator和const_interator</h4><p>声明一个const interator和一个T* const一样，保证指向数据的指针为const；而const_iterator保证数据为const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator citer = vec.<span class="built_in">begin</span>();   <span class="comment">//相当于T* const</span></span><br><span class="line">citer++;                                           <span class="comment">//非法</span></span><br><span class="line">*citer = <span class="number">10</span>;                                       <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iterc = vec.<span class="built_in">begin</span>();   <span class="comment">//相当于const T*</span></span><br><span class="line">iterc++;                                           <span class="comment">//合法</span></span><br><span class="line">*iterc = <span class="number">10</span>;                                       <span class="comment">//非法</span></span><br></pre></td></tr></table></figure>



<h4 id="令函数返回const"><a href="#令函数返回const" class="headerlink" title="令函数返回const"></a>令函数返回const</h4><p>令函数返回一个const，可以降低因客户错误而造成的意外的同时，不至于放弃安全和高效性。考虑有理数（详见条款24）的operator*声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">//客户有时会因粗心而这样做：</span></span><br><span class="line">Rational a, b, c;</span><br><span class="line">(a * b) = c;</span><br></pre></td></tr></table></figure>

<p>将返回值设置为const可避免客户如此操作。</p>
<h4 id="使用const成员函数"><a href="#使用const成员函数" class="headerlink" title="使用const成员函数"></a>使用const成员函数</h4><p>使用const成员函数有两个目的，一是指明了此class接口不会修改对象内容，二是使得函数可以操作const对象。一个事实是：两个成员函数只是常量性不同，可以被重载。也就是说，可以构造两个重载函数，一个用于操作const类型，一个操作non-const类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> lenth[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//此函数中无法修改类的成员，无法对返回值赋值。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> lenth[locate]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此函数中可以修改成员，对返回值赋值会导致成员被修改。</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate)</span><br><span class="line">    &#123; <span class="keyword">return</span> lenth[locate]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存在这样的函数，但会导致通过返回值修改const对象</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> lenth[locate]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数前const限定了无法修改返回值，函数后const决定函数是对const还是non-const对象操作。对于const对象，我们并不希望其被修改，必须重载双const成员函数。</p>
<p>需要注意的是，一个non-const char operator[]返回一个char，诸如<code>name[] = &#39;x&#39;</code>是不被允许的，即使允许，修改的也是一个副本，而原本的数据不会改变。</p>
<h4 id="bitwise-constness和logical-constness"><a href="#bitwise-constness和logical-constness" class="headerlink" title="bitwise constness和logical constness"></a>bitwise constness和logical constness</h4><p>对于const该如何限定，有如上两派观点。BC派认为只有在不更改任何成员变量（static除外）时才能是const。这种观点可以很有效侦测违反点，但当出现指针指向了一个不属于类型的变量，如char* 字符串，const将失效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name[locate];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Name name;</span><br><span class="line">name[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;        <span class="comment">//这条语句将通过编译，而且能够运行，最后结果是const对象的值被改变。</span></span><br></pre></td></tr></table></figure>



<p>LC派认为const对象内可以包含不影响const性的非const对象，一个const成员函数可以修改它所处理的某些bits，但只有在客户端侦测不出时才能如此。使用mutable关键字修饰的变量可在const成员函数中修改。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pText;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">size_t</span> textLength;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;       <span class="comment">//使用mutable关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lengthIsValid == <span class="literal">false</span>) &#123;</span><br><span class="line">		textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">		lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="让non-const调用const成员函数来减少代码重复"><a href="#让non-const调用const成员函数来减少代码重复" class="headerlink" title="让non-const调用const成员函数来减少代码重复"></a>让non-const调用const成员函数来减少代码重复</h4><p>很多情况下const成员函数和non-const成员函数代码基本相同，调用const对象，转化为non-const对象可以减少代码重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> name[locate]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> locate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt; ( <span class="built_in">static_cast</span>&lt;<span class="type">const</span> Name&amp;&gt; (*<span class="keyword">this</span>)[locate] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>将某些东西声明为const有助于编译器侦测出错误用法。</li>
<li>编辑器强制实施bitwise constness，但编写程序时应使用“概念上的常量性”。</li>
<li>当const和non-const成员函数有实质等价的实现时，令non-const版本调用const可避免代码重复。</li>
</ul>
<h2 id="二、构造，析构，赋值运算"><a href="#二、构造，析构，赋值运算" class="headerlink" title="二、构造，析构，赋值运算"></a>二、构造，析构，赋值运算</h2><h3 id="条款04：确定对象使用前已被初始化"><a href="#条款04：确定对象使用前已被初始化" class="headerlink" title="条款04：确定对象使用前已被初始化"></a>条款04：确定对象使用前已被初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name::<span class="built_in">Name</span>(<span class="type">int</span> a, string b, list&lt;<span class="type">int</span>&gt; c)</span><br><span class="line">&#123;</span><br><span class="line">    length = a;       <span class="comment">//是初始化</span></span><br><span class="line">    str = b;          <span class="comment">//不是初始化，而是赋值</span></span><br><span class="line">    listInt = b;      <span class="comment">//不是初始化，而是赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类构造函数，应尽可能使用初始化列表。初始化列表和赋值操作结果相同，但效率更高，原因是在创建成员类的时候无需调用赋值构造函数。应将上述代码改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name::<span class="built_in">Name</span>(<span class="type">int</span> a, string b, list&lt;<span class="type">int</span>&gt; c)</span><br><span class="line">    :<span class="built_in">length</span>(a),</span><br><span class="line">     <span class="built_in">str</span>(b),</span><br><span class="line">     <span class="built_in">listInt</span>(c)</span><br><span class="line">&#123; &#125;                 <span class="comment">//构造函数无需任何操作</span></span><br></pre></td></tr></table></figure>

<p>如果需要一个无参的default构造函数，则仅需指定无物作为初始化列表即可。</p>
<h4 id="将简单初始化移向函数"><a href="#将简单初始化移向函数" class="headerlink" title="将简单初始化移向函数"></a>将简单初始化移向函数</h4><p>对于有多个构造函数的类型，如果一部分内置类型重复，可以考虑将其移到单独的函数中，可以使用赋值初始化（伪初始化）。但通过列表初始化更为可取。</p>
<h4 id="一致声明顺序和初始化顺序"><a href="#一致声明顺序和初始化顺序" class="headerlink" title="一致声明顺序和初始化顺序"></a>一致声明顺序和初始化顺序</h4><p>别问，问就是防止晦涩错误，比如A需要B的值，但B在A后初始化。</p>
<h4 id="不同编译单元内的non-local-static对象的初始化"><a href="#不同编译单元内的non-local-static对象的初始化" class="headerlink" title="不同编译单元内的non-local static对象的初始化"></a>不同编译单元内的non-local static对象的初始化</h4><p>non-local static对象：在本函数内的static对象被称作local static对象，而其他不是函数内的static对象称作non-local static对象。</p>
<p>编译单元：可以理解为不同的两个文件，如两个头文件，各包含了一个static对象，这两个static对象和两个文件之间就是non-local static关系。</p>
<p>由于non-local static对象的初始化顺序并没有一定的规定，所以当一个编译单元的元素需要一个non-local static对象时，有可能该对象还没有被编译。看以下实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;           <span class="comment">//预留给客户的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户在别处使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; tfs;          <span class="comment">//此时tfs不一定完成了初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用tfs的时候该对象不一定完成了初始化。这将导致灾难。解决办法是写一个函数，在函数内构建一个local static对象替换non-local static对象，返回一个指向该对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem tfs;</span><br><span class="line">    <span class="keyword">return</span> tfs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; <span class="built_in">tfs</span>();        <span class="comment">//调用tfs()，获得一个指向non-local tfs的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数简单的reference-returning使得它很适合成为inline函数。对于多线程编程，有可能带有不确定性，需要在单线程启动阶段手动调用所有reference-returning函数。</p>
<p>总结：</p>
<ul>
<li>对内置对象进行手工初始化，因为C++不保证初始化它们。</li>
<li>构造函数最好使用初始化列表，不要在构造函数本体中使用赋值操作。初始化列表的成员顺序需要与声明列表一致。</li>
<li>为了防止跨编译单元的初始化顺序问题，需要使用local static替换non-local static。</li>
</ul>
<h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>对于一个没有提供函数的类，编译器自动为其编写 构造函数，析构函数，复制构造函数以及operator=()运算符函数。如果用户创建了一个含参数的构造函数，编译器将不再自动编写default构造函数。</p>
<p>对于复制构造函数，c++将一一拷贝类型内每个bits来完成初始化（注意复制构造函数仅在创建类时调用，赋值操作使用=运算符），一般不会出现问题，而重载的=运算符在遇到引用和指针时会出现问题，此时编译器拒绝生成对应的operator=()运算符函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> nameLength;</span><br><span class="line">	std::string&amp; name;                       <span class="comment">//成员为引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> <span class="type">int</span>&amp; namel, string&amp; na) :</span><br><span class="line">		<span class="built_in">nameLength</span>(namel),</span><br><span class="line">		<span class="built_in">name</span>(na)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">na1</span><span class="params">(<span class="string">&quot;kringkoter&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">na2</span><span class="params">(<span class="string">&quot;rainimator&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name1</span><span class="params">(<span class="number">2</span>, na1)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name2</span><span class="params">(<span class="number">3</span>, na2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    name1 = name2;             <span class="comment">//不被允许，c++拒绝生成operator=()函数。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误信息：无法引用 函数 &quot;Name::operator=(const Name &amp;)&quot; (已隐式声明) -- 它是已删除的函数</span></span><br></pre></td></tr></table></figure>

<p>如果需要使用一个内含引用或者const对象的类型，必须自己编写operator=函数，编译器不会做这件事。</p>
<p>总结：</p>
<ul>
<li>编译器可以暗自为class创建default构造函数，copy构造函数，copy assignment操作符函数，以及析构函数。</li>
</ul>
<h3 id="条款06：如果不想使用编译器提供的函数，就应当明确拒绝。"><a href="#条款06：如果不想使用编译器提供的函数，就应当明确拒绝。" class="headerlink" title="条款06：如果不想使用编译器提供的函数，就应当明确拒绝。"></a>条款06：如果不想使用编译器提供的函数，就应当明确拒绝。</h3><p>编译器可以自动创建复制和=运算符函数，有时并不希望使用这两个函数，但编译器会自动提供，此时需要明确拒绝。</p>
<h4 id="将函数原型置于private"><a href="#将函数原型置于private" class="headerlink" title="将函数原型置于private"></a>将函数原型置于private</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">Name</span>(<span class="type">const</span> Name&amp;);</span><br><span class="line">    Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将函数原型置于private使得其无法被除成员函数访问，且编译器不再自动提供。</p>
<h4 id="继承Base类，将函数原型置于Base"><a href="#继承Base类，将函数原型置于Base" class="headerlink" title="继承Base类，将函数原型置于Base"></a>继承Base类，将函数原型置于Base</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;);</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Name <span class="title">name1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Name <span class="title">name2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    name1 = name2;      <span class="comment">//非法，错误信息：</span></span><br><span class="line">                        <span class="comment">//无法引用 函数 &quot;Name::operator=(const Name &amp;)&quot; (已隐式声明) -- 它是已删除的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并不予实现。也可以使用base class办法。</li>
</ul>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>如果基类析构函数不是virtual，在析构指向派生类对象的基类指针时，仅仅调用基类析构函数，导致派生类成员无法正确析构，可能会导致内存泄漏。</p>
<p>如果基类含有virtual函数，几乎确定应该有一个virtual析构函数。如果基类不含有virtual函数，表示它并不意图做一个base class，一般不用声明virtual析构函数。</p>
<p>当需要一个抽象基类而又没有适合的纯虚函数时，可以将析构函数声明为纯虚，同时也解决了析构函数为虚的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>带有多态性质的base class应该声明一个virtual析构函数。如果class带有任何virtual函数，应当拥有一个virtual析构函数。</li>
<li>如果类型不是为了多态而设计，或者不是base class，就不该声明virtual析构函数。</li>
</ul>
<h3 id="条款08：-不要让异常逃离析构函数"><a href="#条款08：-不要让异常逃离析构函数" class="headerlink" title="条款08：*不要让异常逃离析构函数"></a>条款08：*不要让异常逃离析构函数</h3><h3 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h3><p>有下列程序段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">con</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Name</span>()</span><br><span class="line">	&#123; <span class="built_in">con</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Len</span> : <span class="keyword">public</span> Name &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">con</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">Len</span>()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在生成Len对象时，首先调用base class构造函数，此时调用的virtual还“不是”virtual函数，它并没有使用派生类中的实现。</p>
<p>由于无法在构造函数中使用virtual函数，可以改用向base class传递必要的构造参量来代替。</p>
<h3 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令operator=返回一个reference to *this</h3><p>基本类型可以使用诸如<code>x = y = z;</code>的连续赋值，自定义类型也最好如此。想要实现这一功能，需要返回一个指向左值的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其他赋值运算符，如+=，-=，*=等，也同样适用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator= 中处理自我赋值"></a>条款11：在operator= 中处理自我赋值</h3><h4 id="证同测试法"><a href="#证同测试法" class="headerlink" title="证同测试法"></a>证同测试法</h4><p>在实现最前面加上证同测试是传统做法，它能够处理自我赋值，但无法处理异常安全性。同时增加的判断语句减慢了代码运行速度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;        <span class="comment">//证同测试</span></span><br><span class="line">    <span class="keyword">delete</span>[] pd;</span><br><span class="line">    pd = <span class="keyword">new</span> <span class="built_in">char</span>(*rhs.pd);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="临时变量法"><a href="#临时变量法" class="headerlink" title="临时变量法"></a>临时变量法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Name&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* newChar = pd;         <span class="comment">//获得一个pd的临时变量</span></span><br><span class="line">    pd = <span class="keyword">new</span> <span class="built_in">char</span>(*rhs.pd);     <span class="comment">//将pd指向新的内存空间，且值等于rhs.pd </span></span><br><span class="line">    <span class="keyword">delete</span>[] newChar;           <span class="comment">//删除临时变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="swap-and-copy法"><a href="#swap-and-copy法" class="headerlink" title="swap and copy法"></a>swap and copy法</h4><p>使用一个swap函数交换*this和rhs的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span>;</span><br><span class="line"><span class="function">Name&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> Name&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Name <span class="title">newName</span><span class="params">(rhs)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(newName);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>确保当对象自我赋值时operator=有良好的行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序，copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><p>每一个类中都会有copying构造函数和operator=函数，如果不显式声明，编译器会提供默认的函数。如果选择使用自己的函数，当有对象没有复制时，编辑器不会发出警告。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> len1;</span><br><span class="line">	<span class="type">int</span> len2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">int</span> l1, <span class="type">int</span> l2) </span><br><span class="line">		: <span class="built_in">len1</span>(l1),</span><br><span class="line">		  <span class="built_in">len2</span>(l2)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">Name</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">		: <span class="built_in">len1</span>(rhs.len1),</span><br><span class="line">		  <span class="built_in">len2</span>(rhs.len2)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		len1 = rhs.len1;</span><br><span class="line">		len2 = rhs.len2;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意将每一个对象都包括在内。</p>
<p>在遇到继承时，要注意复制基类对象。由于继承类无法直接访问基类私有成员，需要调用基类复制构造函数和operator=函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">N</span> : <span class="keyword">public</span> Name &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> len3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">N</span>(<span class="type">int</span> l1, <span class="type">int</span> l2, <span class="type">int</span> l3)</span><br><span class="line">		: <span class="built_in">Name</span>(l1, l2),</span><br><span class="line">		  <span class="built_in">len3</span>(l3)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">N</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">N</span>(<span class="type">const</span> N&amp; rhs)</span><br><span class="line">		: <span class="built_in">Name</span>(rhs),            <span class="comment">//调用基类copying函数</span></span><br><span class="line">		  <span class="built_in">len3</span>(rhs.len3)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	N&amp; <span class="keyword">operator</span>=(<span class="type">const</span> N&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		Name::<span class="keyword">operator</span>=(rhs);   <span class="comment">//调用基类copy assignment函数</span></span><br><span class="line">		len3 = rhs.len3;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>总结</p>
<ul>
<li>copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应该将共同的代码放入一个init函数，并由两个copying函数共同调用。</li>
</ul>
<h2 id="三、资源管理"><a href="#三、资源管理" class="headerlink" title="三、资源管理"></a>三、资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>很多类拥有这样一个函数，它请求内存资源，返回一块内存空间，这样的函数成为factory函数（工厂函数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoffeeBar* <span class="title">creatCOB</span><span class="params">()</span></span>;   <span class="comment">//返回指针，指向COB继承体系内的动态分配对象。</span></span><br></pre></td></tr></table></figure>

<p>由于在函数内使用了new，使用者需要在使用函数后使用delete：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CoffeeBar* newCOB = <span class="built_in">creatCOB</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> CoffeeBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在有的时候，delete有可能会被忽略，比如if，跳出了while，引发了异常等。这时内存得不到释放，即会发生内存泄漏。为确保资源归还给系统，可以把资源的控制权交给资源控制类来实现。可以使用unique_ptr和shared_ptr来管理内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;CoffeeBar&gt; newCOB = <span class="built_in">creatCOB</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;    <span class="comment">//在函数结束前，newCOB的析构函数将删除内存。</span></span><br></pre></td></tr></table></figure>

<p>对于资源管理，有以下两个注意点：</p>
<ul>
<li>获得资源后立刻将资源放入对象，使用资源管理对象来管理资源通常要比手动更加安全。资源取得时机便是初始化时机。</li>
<li>管理对象运用析构函数确保资源被释放。</li>
</ul>
<blockquote>
<p>share_ptr和unique_ptr包含在memory头文件内。</p>
<p>share_ptr被称作引用计数型智慧指针（RCSP），它持续追踪有多少对象指向资源，并在没有指向时删除它。</p>
</blockquote>
<h3 id="条款14：-在资源管理中小心copying行为"><a href="#条款14：-在资源管理中小心copying行为" class="headerlink" title="条款14：*在资源管理中小心copying行为"></a>条款14：*在资源管理中小心copying行为</h3><h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>由于不是所有API都需要资源管理对象，直接访问原始资源显得很重要。比如下面的例子，它需要一个原始指针，但传递了一个智能指针，这是不被允许的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">function</span>(pi);                   <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>需要将智能指针显示转换为普通指针对象，才能通过编译。智能指针对象提供一个get()成员函数，返回一个普通指针指向管理的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">function</span>(pi.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p>有时需要在自己的资源管理类中提供显式和隐式转换函数，用来适配原始资源的API：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ptr</span> &#123;                                         <span class="comment">//这个类处理的是Cob类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Cob <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cob; &#125;                 <span class="comment">//显式转换函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Cob</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cob; &#125;            <span class="comment">//隐式转换函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两者都存在问题，前者使得每次转换都需要条用get()函数（其实也没有那么烦），而隐式转换容易出现意外转换的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ptr <span class="title">newPtr1</span><span class="params">(<span class="keyword">new</span> Cob)</span></span>;</span><br><span class="line">Cob newPtr2 = newPtr1;          <span class="comment">//本意是创建一个ptr对象。</span></span><br><span class="line">                                <span class="comment">//如果不声明隐式转换函数，则不会通过编译，减少了错误可能性。</span></span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>API通常要求访问原始资源，每一个RAII class应该提供一个取得管理的原始资源的方法。</li>
<li>对原始资源的访问可能经由显式和隐式转换，一般而言显示转换更加安全，但隐式转换对于客户来说更加方便。</li>
</ul>
<h3 id="条款16：成对使用new和delete时要采用相同形式"><a href="#条款16：成对使用new和delete时要采用相同形式" class="headerlink" title="条款16：成对使用new和delete时要采用相同形式"></a>条款16：成对使用new和delete时要采用相同形式</h3><p>如果在new表达式中使用[]，必须在相应的delete表达式中也使用[]。尽量避免对数组使用typedef：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string AddressLines[<span class="number">4</span>];</span><br><span class="line">string* pal = <span class="keyword">new</span> AddressLines;        <span class="comment">//这是个4元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;</span><br><span class="line"><span class="keyword">delete</span>[] pal;</span><br></pre></td></tr></table></figure>



<h3 id="条款17：以独立语句将new对象置入智能指针内"><a href="#条款17：以独立语句将new对象置入智能指针内" class="headerlink" title="条款17：以独立语句将new对象置入智能指针内"></a>条款17：以独立语句将new对象置入智能指针内</h3><p>假设有个函数需要传递一个shared_ptr，该函数原型和调用如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt;, <span class="type">int</span> fun)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>(std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="type">int</span>), <span class="built_in">fun</span>());                         <span class="comment">//fun是一个返回int的函数</span></span><br></pre></td></tr></table></figure>

<p>这样的调用可能会产生资源泄漏问题。在调用这样的函数时，需要进行三部操作：1.调用new int，2.调用shared_ptr<int>构造函数，3.调用fun()函数。</p>
<p>c++并没有规定这三者的调用顺序（除了第一步肯定在第二步之前，但第一步和第三步的顺序未定），可能出现调用fun后才调用shared_ptr构造函数，如果在fun中抛出了异常，new int请求的资源就无法进入智能指针中，无法正确析构。</p>
<p>避免这样的情况只需要使用一条单独的语句构造智能指针对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">function</span>(pi, <span class="built_in">fun</span>());</span><br></pre></td></tr></table></figure>

<p>这样即使抛出异常，请求的资源也能正确回到系统中。</p>
<p>总结：</p>
<ul>
<li>以独立语句将newed对象储存于智能指针中，如果不这样做，一旦抛出异常，有可能导致资源泄漏。</li>
</ul>
<h2 id="四、设计与声明"><a href="#四、设计与声明" class="headerlink" title="四、设计与声明"></a>四、设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h3><p>对于一个记录日期的类，它需要三个参数：年，月，日。对于不同的地区，这三个量的排列顺序有可能不同。对于下面的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> valYear, <span class="type">int</span> valMonth, <span class="type">int</span> valDay)</span><br><span class="line">        : <span class="built_in">year</span>(valYear),</span><br><span class="line">          <span class="built_in">month</span>(valMonth),</span><br><span class="line">          <span class="built_in">day</span>(valDay)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数的正确调用应该是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">2004</span>, <span class="number">5</span>, <span class="number">28</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但由于某种地区原因，有人可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(<span class="number">28</span>, <span class="number">5</span>, <span class="number">2004</span>)</span></span>;          <span class="comment">//错误调用</span></span><br></pre></td></tr></table></figure>

<p>避免这样的情况发生，可以指定每一个元素一个数据类型（比如一个结构），取消隐式类型转换，这样使得接口更加清晰明了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> day)</span> </span></span><br><span class="line"><span class="function">        : val(day) </span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="built_in">Month</span>(<span class="type">int</span> month) </span><br><span class="line">        : <span class="built_in">val</span>(month)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function">        : val(year)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Month month;</span><br><span class="line">	Day day;</span><br><span class="line">	Year year;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">const</span> Year&amp; valYear, <span class="type">const</span> Month&amp; valMonth, cosnt Day&amp; valDay)</span><br><span class="line">        : <span class="built_in">year</span>(valYear),</span><br><span class="line">          <span class="built_in">month</span>(valMonth),</span><br><span class="line">          <span class="built_in">day</span>(valDay)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是仍然有问题存在，比如客户传递了错误的月份。可以使用枚举量来代表某个月份，但那样很容易使得枚举量被用作int。所以使用静态成员函数，构造12个月份函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125;;</span><br><span class="line">	<span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> month)</span> : val(month) &#123;</span>&#125;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样调用就会变成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Date <span class="title">date</span><span class="params">(Year(<span class="number">2004</span>), Month::Jan(), Day(<span class="number">28</span>))</span></span>;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>好的接口很容易被正常使用，不容易被误用，应该在所有接口中努力达成这些性质</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
</ul>
<h3 id="条款19：-设计class犹如设计type"><a href="#条款19：-设计class犹如设计type" class="headerlink" title="条款19：*设计class犹如设计type"></a>条款19：*设计class犹如设计type</h3><p>-看书看书看书看书-</p>
<h3 id="条款20：宁以传递const引用替换传值"><a href="#条款20：宁以传递const引用替换传值" class="headerlink" title="条款20：宁以传递const引用替换传值"></a>条款20：宁以传递const引用替换传值</h3><p>pass-by-value很多时候是费事且消耗资源的，在传递用户自定类型时需要传递引用以提高速度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(CoffeeBar cob)</span></span>;          <span class="comment">//传递用户自定义类型有时很消耗资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> CoffeeBar&amp; cob)</span></span>;   <span class="comment">//修改之后</span></span><br></pre></td></tr></table></figure>

<p>使用const使得程序不会在运行中修改数据。</p>
<p>对于内置类型和STL迭代器来说，传递引用有时并不优于传值，对于上述两者考虑使用pass-by-value。</p>
<h4 id="使用pass-by-reference-to-const防止对象切割"><a href="#使用pass-by-reference-to-const防止对象切割" class="headerlink" title="使用pass-by-reference-to-const防止对象切割"></a>使用pass-by-reference-to-const防止对象切割</h4><blockquote>
<p>对象切割：在继承体系中，将子类按值转换为基类时，子类成员丢失，且不具备子类特性（如使用子类virtual函数）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">COB</span> : <span class="keyword">public</span> CoffeeBar &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(CoffeeBar c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c.<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个pass-by-value函数调用中，c.name()将解析为CoffeeBar::name()，而不是COB::name()。原因是按值传递时，c被初始化为基类对象，发生了对象切割。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> CoffeeBar&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c.<span class="built_in">name</span>();                       <span class="comment">//这样就不会了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改如上，现在它能够正确反映多态。c.name()将解析为COB::name()。</p>
<p>总结：</p>
<ul>
<li>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并且可避免对象切割问题。</li>
<li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。</li>
</ul>
<h3 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h3><p>考虑一个有理数类，其中有一个operator*函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num) : <span class="built_in">val</span>(num) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Rational</span>(rhs.val * val);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其operator*函数返回一个对象（而非引用）。这样需要付出额外的构造及析构成本，如果返回reference，则不需付出代价，但是会出现其他很多问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">ra1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">ra2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">Rational ra3 = ra1 * ra2;   <span class="comment">//ra1和ra2返回的引用存在吗？</span></span><br></pre></td></tr></table></figure>

<p>ra1 * ra2的值为30，但有没有值为30的对象呢，又有没有指向这个对象的引用呢？很明显没有。如果operator*要返回一个reference指向此值，必须自己创建对象。</p>
<p>但自己创建对象需要额外的构造及析构成本，这是pass-by-reference的初衷，但这样写已经违反了初衷，还会引发新的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(rhs.val * val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数运行结束后，result对象被析构，此引用指向了一个并不存在的对象，这将导致无定义行为。</p>
<p>如果我们将本在栈区的对象放在堆区呢？这样反而会导致更多问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(rhs.val * val);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实返回了一个可用的引用，但问题是，应该在何处delete请求的资源呢？将这个工作抛给客户是不合理的。</p>
<h3 id="条款22：将成员变量声明为private："><a href="#条款22：将成员变量声明为private：" class="headerlink" title="条款22：将成员变量声明为private："></a>条款22：将成员变量声明为private：</h3><p>如果将成员变量声明为public或protected，意味着当某个变量发生改变（改名，或者是删除）时，客户码将会大幅度变化。另外，需要考虑封装性，当某个方法的实现改变时，客户不应当知道，也不应当需要修改客户码。</p>
<p>某物的封装性和“当改变其内容时造成的代码破坏量”成反比。protected和public一样，没有封装性。</p>
<p>记住：</p>
<ul>
<li>切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束调节获得保证，并提供class作者充分的弹性。</li>
<li>protected并不比public更具封装性。</li>
</ul>
<h3 id="条款23：宁以non-member-non-friend函数代替member函数"><a href="#条款23：宁以non-member-non-friend函数代替member函数" class="headerlink" title="条款23：宁以non-member, non-friend函数代替member函数"></a>条款23：宁以non-member, non-friend函数代替member函数</h3><p>对于一个CoffeeBar类，其拥有三个成员变量，三个重置成员变量的函数。此时需要一个重置所有变量的函数，该函数有成员函数版本和非成员函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val1, val2, val3;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> v3)</span><br><span class="line">		: <span class="built_in">val1</span>(v1),</span><br><span class="line">		  <span class="built_in">val2</span>(v2),</span><br><span class="line">		  <span class="built_in">val3</span>(v3)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV1</span><span class="params">()</span> </span>&#123; val1 = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV2</span><span class="params">()</span> </span>&#123; val2 = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV3</span><span class="params">()</span> </span>&#123; val3 = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetAll</span><span class="params">()</span>                      <span class="comment">//成员函数版本</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">resetV1</span>();</span><br><span class="line">		<span class="built_in">resetV2</span>();</span><br><span class="line">		<span class="built_in">resetV3</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetCob</span><span class="params">(CoffeeBar&amp; cob)</span>            <span class="comment">//非成员函数版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cob.<span class="built_in">resetV1</span>();</span><br><span class="line">	cob.<span class="built_in">resetV2</span>();</span><br><span class="line">	cob.<span class="built_in">resetV3</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象守则要求，数据尽可能被封装。而封装性的判断标准从简单来说是：越多函数（member函数和friend函数）可以访问成员变量，封装性越差。</p>
<p>c++倾向于使用非成员函数，且非成员函数可以放在一个ntility工具类中，成为一个static函数。只要它不是CoffeeBar的一部分，他就不会影响封装性。比较自然的做法是让resetAll成为一个non-member函数并位于和Coffeebar相同的namespace内。</p>
<p>namespace可以跨越文件，而class不能。namespace内的对象可以不放在同一个文件中，只需要指名它属于同一个namesapce就可以了。</p>
<p>c++STL就是如此组织的，比如string，vector类，只需要包含特定的头文件，但它们都在namespaec std中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cob &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val1, val2, val3;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> v3)</span><br><span class="line">		: <span class="built_in">val1</span>(v1),</span><br><span class="line">		  <span class="built_in">val2</span>(v2),</span><br><span class="line">		  <span class="built_in">val3</span>(v3)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV1</span><span class="params">()</span> </span>&#123; val1 = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV2</span><span class="params">()</span> </span>&#123; val2 = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetV3</span><span class="params">()</span> </span>&#123; val3 = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cob &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetCob</span><span class="params">(CoffeeBar&amp; cob)</span>            <span class="comment">//非成员函数版本</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cob.<span class="built_in">resetV1</span>();</span><br><span class="line">		cob.<span class="built_in">resetV2</span>();</span><br><span class="line">		cob.<span class="built_in">resetV3</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性，包裹弹性和机能扩充性。</li>
</ul>
<h3 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>对于一个有理数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">val</span>(num)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于它是有理数类型，我们希望它能够和基本类型进行更加“明显的”乘法运算，比如ran * 4，首先4通过隐式类型转换，自动调用了构造函数转换为了Rational对象，再通过一个operator*函数返回一个Rational对象。如果乘法运算符函数是个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(val, rhs.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">ran</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; ran * <span class="number">4</span>;       <span class="comment">//正确</span></span><br><span class="line">cout &lt;&lt; <span class="number">4</span> * ran        <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>第二条语句不能通过编译，原因如同下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ran.<span class="keyword">operator</span>*(<span class="number">4</span>);      <span class="comment">//正确</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">operator</span>*(ran);      <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>4没有对应的class，所以编译器试图寻找成员函数operator*失败，于是它在global寻找非成员函数版的operator函数，但没有找到。</p>
<p>4不在operator*()的参数列中（即函数调用不是operator(4）），无法进行隐式类型转换。此时需要一个非成员函数版本的运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> num)</span><br><span class="line">		: <span class="built_in">val</span>(num)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">Rational</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span>          <span class="comment">//由于运算符函数传递const参数，后面的const是必须的</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">getVal</span>() * rhs.<span class="built_in">getVal</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果自定义的类型不必将所有类型转换为自定义类型，诸如此类的函数可以是member函数。</p>
<p>总结：</p>
<ul>
<li>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member。</li>
</ul>
<h3 id="条款25：-考虑写出一个不抛出异常的swap函数"><a href="#条款25：-考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：*考虑写出一个不抛出异常的swap函数"></a>条款25：*考虑写出一个不抛出异常的swap函数</h3><h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><h3 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h3><p>当定义了一个带有构造函数和析构函数的对象时，如果这个对象实际并未使用，仍需承受构造和析构成本。第二是当出现异常时，未使用的资源可能会浪费。</p>
<p>处理方法则是，只有当下一步就要用到这个对象，且可以对其进行初始化时，才能创建该对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;KringKoter&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> lenth = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>对于循环来说，在循环外声明的变量可以延续至循环后，且不必重复构造；但其可能重复调用复制函数。用哪个方法视具体情况而定。</p>
<p>总结：</p>
<ul>
<li>尽可能延后变量定义式的出现。这样做可以增加程序的清晰度并改善程序效率。</li>
</ul>
<h3 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h3><p>c++提供了四种“新式转型”，应在程序中代替旧式转型以增强程序可读性：</p>
<ul>
<li>const_cast&lt;&gt;通常用来将对象的常量性移除，它是唯一有此权力的c++ style转型操作符。</li>
<li>dynamic_cast&lt;&gt;用来执行“安全向下转型，它的运行成本耗费重大。</li>
<li>reinterpret_cast&lt;&gt;执行低级转型，如将一个int指针转化为int。</li>
<li>static_cast&lt;&gt;执行强制类型转换，可以将non-const对象转化为const，但无法反向将const转化为non-const。</li>
</ul>
<h4 id="转型获得的是副本"><a href="#转型获得的是副本" class="headerlink" title="转型获得的是副本"></a>转型获得的是副本</h4><p>就static_cast而言，其转换操作只是获得了其一个副本，其本身数据并没有改变。在继承体系中，尝试调用基类方法不能这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;base&gt;(*<span class="keyword">this</span>).<span class="built_in">function</span>();</span><br></pre></td></tr></table></figure>

<p>它其实调用了一个base副本的函数，并没有修改原始对象。应该这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base::<span class="built_in">function</span>();</span><br></pre></td></tr></table></figure>



<h4 id="少用dynamic-cast，而改为直接使用派生类指针。"><a href="#少用dynamic-cast，而改为直接使用派生类指针。" class="headerlink" title="少用dynamic_cast，而改为直接使用派生类指针。"></a>少用dynamic_cast，而改为直接使用派生类指针。</h4><p>dynamic_cast转型需要耗费大量资源和时间，尝试替换下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Base&gt; newDerive;</span><br><span class="line"><span class="function"><span class="keyword">dynamic_cast</span>&lt;Derived*&gt; <span class="title">derive</span><span class="params">(newDerive-&gt;get())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line">shared_ptr&lt;Derived&gt; newDerive;</span><br><span class="line"><span class="function">Derived* <span class="title">derive</span><span class="params">(newDerive-&gt;get())</span></span>;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>如果可以，尽量避免转型，特别是注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，设计无需转型的代替设计。</li>
<li>如果转型是必要的，将其放入函数。客户可以调用该函数。</li>
<li>宁可使用c++ style转型，不要使用旧式转型。前者很容易辨识。</li>
</ul>
<h3 id="条款28：避免返回handles指向对象的内部成分"><a href="#条款28：避免返回handles指向对象的内部成分" class="headerlink" title="条款28：避免返回handles指向对象的内部成分"></a>条款28：避免返回handles指向对象的内部成分</h3><p>考虑下面的对象，其使用一个结构来保存val，并在对象内使用指针指向结构来节省内存。考虑其成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;v&gt; pv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">getVal</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pv-&gt;val; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">Name <span class="title">name</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="type">int</span>&amp; n = name.<span class="built_in">getVal</span>();</span><br><span class="line">n = <span class="number">100</span>;                  <span class="comment">//修改了成员数据</span></span><br></pre></td></tr></table></figure>

<p>由于返回了一个引用（套指针，如果此例没使用指针的话会编译出错，此条例有限制条件），在外部可以修改内部数据。而且当对象析构时，内部对象不复存在，而外部引用仍然指向内部对象，这会导致引用或指针挂起。</p>
<p>总结：</p>
<ul>
<li>避免返回引用，指针，迭代器指向对象内部。这样可以增加封装性，帮助const对象的行为像个const，并减少发生虚吊引用或指针的情况。</li>
</ul>
<h3 id="条款29：-“为异常安全”而努力是值得的"><a href="#条款29：-“为异常安全”而努力是值得的" class="headerlink" title="条款29：*“为异常安全”而努力是值得的"></a>条款29：*“为异常安全”而努力是值得的</h3><h3 id="条款30：透彻了解inline的里里外外"><a href="#条款30：透彻了解inline的里里外外" class="headerlink" title="条款30：透彻了解inline的里里外外"></a>条款30：透彻了解inline的里里外外</h3><h4 id="inline的组织方式"><a href="#inline的组织方式" class="headerlink" title="inline的组织方式"></a>inline的组织方式</h4><p>编译器处理inline函数的方式是，对于inline函数的每个调用，都使用相应的代码来代替它。当函数inline的代码很少时，编译器产出的代码可能比直接调用函数更少。如果如此，将增加程序的处理速度。但是，使用代码来替换调用使得inline函数没有地址，对其的函数指针将创建一个outline函数对象。</p>
<h4 id="请求inline函数"><a href="#请求inline函数" class="headerlink" title="请求inline函数"></a>请求inline函数</h4><p>inline关键字只是一个对编译器的申请，编译器有权利不理会。有时候inline函数并不需要明确指出，只需将函数定义于class内。这样的函数通常是成员函数，定义于class内的friend函数也是inline：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> val; &#125;       <span class="comment">//隐式的inline函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明确声明为inline需要使用inline关键字，inline函数通常声明于头文件之内，因为编译器需要知道其如何实现。function template通常也声明于头文件内，很多程序员认为template函数一定要声明为inline。但这是个错误的想法，只有当确定其所有版本的函数都需要inline，才能将其声明为inline。</p>
<h4 id="编译器可能拒绝inline"><a href="#编译器可能拒绝inline" class="headerlink" title="编译器可能拒绝inline"></a>编译器可能拒绝inline</h4><p>有的时候编译器确实有意向生成一个inline，但还是为其提供一个outline函数对象。编译器通常不对virtual函数实行inline，因为需要等待运行期才能知道调用哪个函数。</p>
<p>空的构造函数看上去很适合成为inline函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> : <span class="keyword">public</span> Coffeebar&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但空的构造函数实际上并不是空的。编译器在其中添加了Base class的构造函数，初始化str和其他变量的方法，异常处理……如果上述函数也是inline，构造函数的代码量将极其庞大。</p>
<p>同时，将函数声明为inling会使得程序的更新变得复杂。在改变inline函数后，客户端需要重新编译。</p>
<p>掌握一个合乎逻辑的规则：一开始先不声明任何函数为inline，在合理的情况下声明为inline，并竭力减少其代码量。</p>
<h3 id="条款31：将文件之间的编译关系降到最低"><a href="#条款31：将文件之间的编译关系降到最低" class="headerlink" title="条款31：将文件之间的编译关系降到最低"></a>条款31：将文件之间的编译关系降到最低</h3><p>一个类的定义式不止详细叙述了其接口，还包括了十足的实现细目。当我们改变实现（甚至仅仅是一个变量的名字）时，所有有关文件都需要重新编译连接。但如果提供声明式，客户看到的只是接口，而无关实现。当实现改变时，和接口没有关系，客户便无需修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义式，包含了所有实现细目。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cob.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式，仅包含接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cob</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类型的实现十分庞大时，当其实现代码改变时，我们需要重新编译连接。我们并不希望这样的情况发生。</p>
<h4 id="handle-class法"><a href="#handle-class法" class="headerlink" title="handle class法"></a>handle class法</h4><p>handle class将类型拆分为二，一个仅包含接口，通过一个指针指向另一个；另一个包含完整实现。这样，当实现改变时，客户无需重新编译连接，因为接口没有发生改变。</p>
<p>Implementation.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBarImpl</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CoffeeBarImpl</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">name</span>(name_), <span class="built_in">age</span>(age_)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CoffeeBarImpl</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; age = val; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> </span>&#123; name = val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CoffeeBar.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;implementation.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;CoffeeBarImpl&gt; pImpl;       <span class="comment">//指向imlp的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CoffeeBar</span>(<span class="type">const</span> std::string&amp; name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">CoffeeBarImpl</span>(name_, age_))</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CoffeeBar</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Coffeebar.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Coffeebar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;implementation.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CoffeeBar::getAge</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pImpl-&gt;<span class="built_in">getAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CoffeeBar::setAge</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pImpl-&gt;<span class="built_in">setAge</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">CoffeeBar::getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pImpl-&gt;<span class="built_in">getName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CoffeeBar::setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pImpl-&gt;<span class="built_in">setName</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Implementation提供了实现细目，而Coffeebar只是调用其中的方法。将定义式和声明式置于两个不同的头文件中，客户在使用时只需要包含声明式头文件即可。</p>
<h4 id="Interface-class法"><a href="#Interface-class法" class="headerlink" title="Interface class法"></a>Interface class法</h4><p>interface class法声明一个抽象基类，使用该抽象基类派生一个类。基类和派生类拥有一样的接口，但具体实现在派生类中。基类中包含一个factory函数，生产一个指向派生类的基类指针供使用。在使用时，调用factory函数获得一个指向派生类的基类指针，使用基类virtual接口，调用实际是派生类方法。</p>
<p>Base.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">COBBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> std::shared_ptr&lt;COBBase&gt; <span class="title">creatCOB</span><span class="params">(<span class="type">const</span> std::string name_, <span class="type">int</span> age_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;COBBase&gt;(<span class="keyword">new</span> <span class="built_in">Coffeebar</span>(name_, age_));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回基类指针，指向派生类对象，可使用派生类virtual函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">COBBase</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Coffeebar.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coffeebar</span> : <span class="keyword">public</span> COBBase &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Coffeebar</span>(<span class="type">const</span> std::string name_, <span class="type">int</span> age_)</span><br><span class="line">		: <span class="built_in">name</span>(name_),</span><br><span class="line">		  <span class="built_in">age</span>(age_)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Coffeebar</span>()</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数实现文件和上一个方法基本一致。</p>
<p>总结：</p>
<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle class和interface class（将接口和实现分离）。</li>
</ul>
<h2 id="六、继承与面向对象"><a href="#六、继承与面向对象" class="headerlink" title="六、继承与面向对象"></a>六、继承与面向对象</h2><h3 id="条款32：确定在你的public继承塑膜出is-a关系"><a href="#条款32：确定在你的public继承塑膜出is-a关系" class="headerlink" title="条款32：确定在你的public继承塑膜出is-a关系"></a>条款32：确定在你的public继承塑膜出is-a关系</h3><p>class之间的关系有三种：is-a，has-a，is-implemented-in-terms-of（根据某物实现出）。public继承要求严格is-a关系，也就是适用于base的每一件事情都适用于derived class。每一个derived class对象都是一个base class对象。</p>
<h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p>在继承体系中，如果派生类尝试重载基类接口，基类接口将直接被掩盖，而并非被重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">()</span> </span>&#123; val = <span class="number">5</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">()</span> </span>&#123; val = <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//即使接口只改变了参数列表，仍然不是重载，而是覆盖</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123; <span class="built_in">getVal</span>() = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="built_in">getVal</span>() = <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解决方法：使用using指令，使得基类函数作用域扩大：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用using</span></span><br><span class="line">    <span class="comment">//现在set1有两个重载版本：set1(), set1(int)</span></span><br><span class="line">	<span class="keyword">using</span> Base::set1;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set1</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123; <span class="built_in">getVal</span>() = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="built_in">getVal</span>() = <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="补充：函数与作用域"><a href="#补充：函数与作用域" class="headerlink" title="补充：函数与作用域"></a>补充：函数与作用域</h4><p>假设一个derived class的方法像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器看到这里的fun时，它会现在local作用域（也就是baseFun中查找），但一无所获。之后它将查找其外围作用域，即Dervied class中，仍然一无所获。在之后它查找Derived class外，也就是Base class中，如果找到，则停止查找。如果再没有找到，它将检索#include的头文件中是否存在。如果还是没有，则发生编译时错误。</p>
<p>总结：</p>
<ul>
<li>derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的函数重见天日，成为一个重载版本，可使用using声明式。</li>
</ul>
<h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p>在对基类方法的继承中，我们可能需要</p>
<ul>
<li>仅继承接口，并要求派生类提供实现</li>
<li>继承接口和实现，但希望派生类覆写实现</li>
<li>继承接口和实现，且不允许覆写实现</li>
</ul>
<p>对应的方法类型为pure virtual函数，simple pure virtual函数和non virtual函数。</p>
<h4 id="仅继承接口，要求派生类提供实现"><a href="#仅继承接口，要求派生类提供实现" class="headerlink" title="仅继承接口，要求派生类提供实现"></a>仅继承接口，要求派生类提供实现</h4><p>一个抽象基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的派生类只继承了它的接口，即函数定义，但没有实现。派生类需要自己提供实现。</p>
<ul>
<li>声明一个pure virtual函数的目的是让derived class只继承接口。</li>
</ul>
<p>然而，可以给纯虚函数提供一份实现代码，由于抽象类无法创建具体对象，只有通过VirtualBase::draw()来访问：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Virtual::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VirtualBase::<span class="built_in">draw</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>



<h4 id="继承接口和实现，但希望派生类覆写实现"><a href="#继承接口和实现，但希望派生类覆写实现" class="headerlink" title="继承接口和实现，但希望派生类覆写实现"></a>继承接口和实现，但希望派生类覆写实现</h4><p>simple virtual函数通常会提供一份实现代码，在派生类缺省时调用。虽然派生类可以对其覆写，但仍然可以使用其缺省版本。它告诉客户：你必须支持一个virtual函数，但如果你不想自己写， 你可以使用基类的缺省版本。</p>
<ul>
<li>simple virtual函数是让derived继承该函数的接口和缺省实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺省代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Virtual::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样存在问题：如果客户新建类型继承自此基类，但忘记了覆写代码，其将自动调用缺省实现，且不会发生编译器错误（错误在编译器出现要好于在运行期出现）。</p>
<p>解决方法是：除非用户提出使用缺省实现，否则不提供。</p>
<ul>
<li>提供一份缺省代码，置于protected中：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doDraw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">paint</span>(locate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用缺省实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span> : <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用覆写实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span> : <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doOther</span>(locate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>将原simple virtual函数改为pure virtual函数，提供一份该函数的实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VirtualBase::draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">paint</span>(locate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用缺省实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span> : <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VirtualBase::<span class="built_in">draw</span>(locate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用覆写实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span> : <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> locate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doOther</span>(locate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="继承接口和实现，且不允许覆写实现"><a href="#继承接口和实现，且不允许覆写实现" class="headerlink" title="继承接口和实现，且不允许覆写实现"></a>继承接口和实现，且不允许覆写实现</h4><ul>
<li>声明non-virtual函数的目的是为了零derived class继承函数的接口及一份强制性实现。</li>
</ul>
<p>总结：</p>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>pure virtual函数只指定接口继承。</li>
<li>simple virtual函数具体指定接口继承且提供缺省实现。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p>当继承的函数是virtual或pure virtual，且提供了一份缺省参数时，重新定义缺省参数值将引发错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> val = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(string val = <span class="string">&quot;NONE&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A* pb = <span class="keyword">new</span> B;     <span class="comment">//创建一个A指向B的指针</span></span><br><span class="line">B-&gt;<span class="built_in">draw</span>();         <span class="comment">//调用B的draw函数，没有提供参数。</span></span><br></pre></td></tr></table></figure>

<p>在没有提供参数的情况下，B的draw函数提供了来自A的默认参数，即B-&gt;draw(int val = 0)。</p>
<p>解决办法：将virtual函数置于private，并提供一个non-virtual函数提供缺省参数。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2023/05/08/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
      title="C++并发编程"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        C++并发编程
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2023/04/23/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8%E7%9A%84python/"
      title="从入门到入门的python"
     >

    <p class="title-text">
      
        从入门到入门的python
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Your Name<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
